[
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "copy",
    "Body": "copy function calls Object.Copy\ninterface method, which is expected to return a deep-copy of the value it holds.",
    "Desc": " function calls Object.Copy\ninterface method, which is expected to return a deep-copy of the value it holds."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "Object.Copy",
    "Body": "Object.Copy\ninterface method, which is expected to return a deep-copy of the value it holds.",
    "Desc": "\ninterface method, which is expected to return a deep-copy of the value it holds."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "append",
    "Body": "append builtin.) Currently, this function takes array type only.",
    "Desc": " builtin.) Currently, this function takes array type only."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "delete",
    "Body": "delete builtin except keys are always string).\ndelete returns undefined value if successful and it mutates given map.",
    "Desc": " builtin except keys are always string).\ndelete returns undefined value if successful and it mutates given map."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "delete",
    "Body": "delete returns undefined value if successful and it mutates given map.",
    "Desc": " returns undefined value if successful and it mutates given map."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "undefined",
    "Body": "undefined value if successful and it mutates given map.",
    "Desc": " value if successful and it mutates given map."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "splice",
    "Body": "splice is similar to\nJS Array.prototype.splice() except splice is a builtin function and\nfirst argument must an array. First argument must be an array, and\nif second and third arguments are provided those must be integers\notherwise runtime error is returned.",
    "Desc": " is similar to\nJS Array.prototype.splice() except splice is a builtin function and\nfirst argument must an array. First argument must be an array, and\nif second and third arguments are provided those must be integers\notherwise runtime error is returned."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "Array.prototype.splice()",
    "Body": "Array.prototype.splice() except splice is a builtin function and\nfirst argument must an array. First argument must be an array, and\nif second and third arguments are provided those must be integers\notherwise runtime error is returned.",
    "Desc": " except splice is a builtin function and\nfirst argument must an array. First argument must be an array, and\nif second and third arguments are provided those must be integers\notherwise runtime error is returned."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "deleted_items := splice(array[, start[, delete_count[, item1[, item2[, ...]]]])",
    "Body": "deleted_items := splice(array[, start[, delete_count[, item1[, item2[, ...]]]])",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "bytes()",
    "Body": "bytes() function, it will create a new byte object with\nthe given size.",
    "Desc": " function, it will create a new byte object with\nthe given size."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is string. Or it returns false.",
    "Desc": " if the object's type is string. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is int. Or it returns false.",
    "Desc": " if the object's type is int. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is bool. Or it returns false.",
    "Desc": " if the object's type is bool. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is float. Or it returns false.",
    "Desc": " if the object's type is float. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is char. Or it returns false.",
    "Desc": " if the object's type is char. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is bytes. Or it returns false.",
    "Desc": " if the object's type is bytes. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is error. Or it returns false.",
    "Desc": " if the object's type is error. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is undefined. Or it returns false.",
    "Desc": " if the object's type is undefined. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is function or closure. Or it returns\nfalse. Note that is_function returns false for builtin functions and\nuser-provided callable objects.",
    "Desc": " if the object's type is function or closure. Or it returns\nfalse. Note that is_function returns false for builtin functions and\nuser-provided callable objects."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false. Note that is_function returns false for builtin functions and\nuser-provided callable objects.",
    "Desc": ". Note that is_function returns false for builtin functions and\nuser-provided callable objects."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "is_function",
    "Body": "is_function returns false for builtin functions and\nuser-provided callable objects.",
    "Desc": " returns false for builtin functions and\nuser-provided callable objects."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false for builtin functions and\nuser-provided callable objects.",
    "Desc": " for builtin functions and\nuser-provided callable objects."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object is callable (e.g. function, closure, builtin\nfunction, or user-provided callable objects). Or it returns false.",
    "Desc": " if the object is callable (e.g. function, closure, builtin\nfunction, or user-provided callable objects). Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is array. Or it returns false.",
    "Desc": " if the object's type is array. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is immutable array. Or it returns false.",
    "Desc": " if the object's type is immutable array. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is map. Or it returns false.",
    "Desc": " if the object's type is map. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is immutable map. Or it returns false.",
    "Desc": " if the object's type is immutable map. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is iterable: array, immutable array, map,\nimmutable map, string, and bytes are iterable types in Tengo.",
    "Desc": " if the object's type is iterable: array, immutable array, map,\nimmutable map, string, and bytes are iterable types in Tengo."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "true",
    "Body": "true if the object's type is time. Or it returns false.",
    "Desc": " if the object's type is time. Or it returns false."
  },
  {
    "Type": 0,
    "Module": "builtins",
    "Object": "",
    "Code": "false",
    "Body": "false.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "extlib-bootstrap",
    "Object": "Functions",
    "Code": "bootstrap.run()=\u003eobject",
    "Body": "bootstrap.run()=\u003eobjectFunctions: 运行初始化脚本",
    "Desc": ": 运行初始化脚本"
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "Functions",
    "Code": "dial(url)=\u003eRedisClient",
    "Body": "dial(url)=\u003eRedisClientFunctions: 连接到redis库，其中url格式：redis://user:password@localhost:6789/3?dial_timeout=3\u0026db=1\u0026read_timeout=6s\u0026max_retries=2",
    "Desc": ": 连接到redis库，其中url格式：redis://user:password@localhost:6789/3?dial_timeout=3\u0026db=1\u0026read_timeout=6s\u0026max_retries=2"
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "Functions",
    "Code": "url",
    "Body": "urlFunctions格式：redis://user:password@localhost:6789/3?dial_timeout=3\u0026db=1\u0026read_timeout=6s\u0026max_retries=2",
    "Desc": "格式：redis://user:password@localhost:6789/3?dial_timeout=3\u0026db=1\u0026read_timeout=6s\u0026max_retries=2"
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "Functions",
    "Code": "redis://user:password@localhost:6789/3?dial_timeout=3\u0026db=1\u0026read_timeout=6s\u0026max_retries=2",
    "Body": "redis://user:password@localhost:6789/3?dial_timeout=3\u0026db=1\u0026read_timeout=6s\u0026max_retries=2Functions",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "RedisClient",
    "Code": "set(key,value,[ttl])=\u003eStatusCmd",
    "Body": "set(key,value,[ttl])=\u003eStatusCmdRedisClient: 设置redis值,TTL值默认1小时。如果要设置更长的时间，参考：\nset(key,value,5*times.hour),如果设置永不过期：  set(key,value,-1)",
    "Desc": ": 设置redis值,TTL值默认1小时。如果要设置更长的时间，参考：\nset(key,value,5*times.hour),如果设置永不过期：  set(key,value,-1)"
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "RedisClient",
    "Code": "set(key,value,5*times.hour)",
    "Body": "set(key,value,5*times.hour)RedisClient,如果设置永不过期：  set(key,value,-1)",
    "Desc": ",如果设置永不过期：  set(key,value,-1)"
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "RedisClient",
    "Code": "set(key,value,-1)",
    "Body": "set(key,value,-1)RedisClient",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "RedisClient",
    "Code": "setnx(key,value)=\u003eStatudCmd",
    "Body": "setnx(key,value)=\u003eStatudCmdRedisClient: 参考set的设置，通常用于事务性的操作",
    "Desc": ": 参考set的设置，通常用于事务性的操作"
  },
  {
    "Type": 0,
    "Module": "extlib-redis",
    "Object": "RedisClient",
    "Code": "get(key)=\u003eStringCmd",
    "Body": "get(key)=\u003eStringCmdRedisClient: 获取redis中的值",
    "Desc": ": 获取redis中的值"
  },
  {
    "Type": 0,
    "Module": "extlib-sys",
    "Object": "Functions",
    "Code": "sys.prop(name)=\u003estring",
    "Body": "sys.prop(name)=\u003estringFunctions: 获取系统配置，例如：sys.prop(\"os.name\")",
    "Desc": ": 获取系统配置，例如：sys.prop(\"os.name\")"
  },
  {
    "Type": 0,
    "Module": "extlib-sys",
    "Object": "Functions",
    "Code": "sys.prop(\"os.name\")",
    "Body": "sys.prop(\"os.name\")Functions",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "extlib-sys",
    "Object": "Functions",
    "Code": "sys.env(name)=\u003estring",
    "Body": "sys.env(name)=\u003estringFunctions: 获取系统环境变量，例如：sys.env(\"HOME\")",
    "Desc": ": 获取系统环境变量，例如：sys.env(\"HOME\")"
  },
  {
    "Type": 0,
    "Module": "extlib-sys",
    "Object": "Functions",
    "Code": "sys.env(\"HOME\")",
    "Body": "sys.env(\"HOME\")Functions",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "extlib-sys",
    "Object": "Functions",
    "Code": "sys.config()=\u003emap[string]object",
    "Body": "sys.config()=\u003emap[string]objectFunctions: 获取系统配置，例如：sys.config()",
    "Desc": ": 获取系统配置，例如：sys.config()"
  },
  {
    "Type": 0,
    "Module": "extlib-sys",
    "Object": "Functions",
    "Code": "sys.config()",
    "Body": "sys.config()Functions",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "b",
    "Body": "b is defined by the user before compilation using\n function. Then a\ncompiled bytecode c is used to execute the bytecode and get the value of\nglobal variables. In this example, the value of global variable a is read\nusing \nfunction. See\n for the\nfull list of variable value functions.",
    "Desc": " is defined by the user before compilation using\n function. Then a\ncompiled bytecode c is used to execute the bytecode and get the value of\nglobal variables. In this example, the value of global variable a is read\nusing \nfunction. See\n for the\nfull list of variable value functions."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "c",
    "Body": "c is used to execute the bytecode and get the value of\nglobal variables. In this example, the value of global variable a is read\nusing \nfunction. See\n for the\nfull list of variable value functions.",
    "Desc": " is used to execute the bytecode and get the value of\nglobal variables. In this example, the value of global variable a is read\nusing \nfunction. See\n for the\nfull list of variable value functions."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "a",
    "Body": "a is read\nusing \nfunction. See\n for the\nfull list of variable value functions.",
    "Desc": " is read\nusing \nfunction. See\n for the\nfull list of variable value functions."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "x",
    "Body": "x in the example)",
    "Desc": " in the example)"
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "nil",
    "Body": "nil",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Undefined",
    "Body": "Undefined",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "string",
    "Body": "string",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "String",
    "Body": "String",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "int64",
    "Body": "int64",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Int",
    "Body": "Int",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "int",
    "Body": "int",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Int",
    "Body": "Int",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "bool",
    "Body": "bool",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Bool",
    "Body": "Bool",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "rune",
    "Body": "rune",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Char",
    "Body": "Char",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "byte",
    "Body": "byte",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Char",
    "Body": "Char",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "float64",
    "Body": "float64",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Float",
    "Body": "Float",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "[]byte",
    "Body": "[]byte",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Bytes",
    "Body": "Bytes",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "time.Time",
    "Body": "time.Time",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Time",
    "Body": "Time",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "error",
    "Body": "error",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Error{String}",
    "Body": "Error{String}",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "error.Error()",
    "Body": "error.Error() as String value",
    "Desc": " as String value"
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "map[string]Object",
    "Body": "map[string]Object",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Map",
    "Body": "Map",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "map[string]interface{}",
    "Body": "map[string]interface{}",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Map",
    "Body": "Map",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "[]Object",
    "Body": "[]Object",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Array",
    "Body": "Array",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "[]interface{}",
    "Body": "[]interface{}",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Array",
    "Body": "Array",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Object",
    "Body": "Object",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Object",
    "Body": "Object",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "objects.SourceModule",
    "Body": "objects.SourceModule\n(which implements objects.Importable).",
    "Desc": "\n(which implements objects.Importable)."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "objects.Importable",
    "Body": "objects.Importable).",
    "Desc": ")."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "tengo.ModuleGetter",
    "Body": "tengo.ModuleGetter.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "-1",
    "Body": "-1) if you don't need to limit the number of allocations.",
    "Desc": ") if you don't need to limit the number of allocations."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Compiled",
    "Body": "Compiled) can be used to run the code multiple\ntimes by a goroutine. If you want to run the compiled script by multiple\ngoroutine, you should use Compiled.Clone function to make a copy of Compiled\ninstances.",
    "Desc": ") can be used to run the code multiple\ntimes by a goroutine. If you want to run the compiled script by multiple\ngoroutine, you should use Compiled.Clone function to make a copy of Compiled\ninstances."
  },
  {
    "Type": 0,
    "Module": "interoperability",
    "Object": "",
    "Code": "Compiled.Clone",
    "Body": "Compiled.Clone function to make a copy of Compiled\ninstances.",
    "Desc": " function to make a copy of Compiled\ninstances."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "+",
    "Body": "+, -, *, /, %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", -, *, /, %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "-",
    "Body": "-, *, /, %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", *, /, %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "*",
    "Body": "*, /, %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", /, %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "/",
    "Body": "/, %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", %, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "%",
    "Body": "%, \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", \u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u0026",
    "Body": "\u0026, |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", |, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "|",
    "Body": "|, ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", ^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "^",
    "Body": "^, \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", \u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u0026^",
    "Body": "\u0026^, \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", \u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003e\u003e",
    "Body": "\u003e\u003e, \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", \u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003c\u003c",
    "Body": "\u003c\u003c, \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", \u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003e",
    "Body": "\u003e, \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": ", \u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003e=",
    "Body": "\u003e=; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": "; ) by\nimplementing BinaryOp method. BinaryOp method takes the operator op and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003c",
    "Body": "\u003c and \u003c= operators are not overloadable as they're simply implemented\nby switching left-hand side and right-hand side of \u003e/\u003e= operator",
    "Desc": " and \u003c= operators are not overloadable as they're simply implemented\nby switching left-hand side and right-hand side of \u003e/\u003e= operator"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003c=",
    "Body": "\u003c= operators are not overloadable as they're simply implemented\nby switching left-hand side and right-hand side of \u003e/\u003e= operator",
    "Desc": " operators are not overloadable as they're simply implemented\nby switching left-hand side and right-hand side of \u003e/\u003e= operator"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003e",
    "Body": "\u003e/\u003e= operator",
    "Desc": "/\u003e= operator"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "\u003e=",
    "Body": "\u003e= operator",
    "Desc": " operator"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "op",
    "Body": "op and the\nright-hand side object rhs, and, should return a resulting value res.",
    "Desc": " and the\nright-hand side object rhs, and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "rhs",
    "Body": "rhs, and, should return a resulting value res.",
    "Desc": ", and, should return a resulting value res."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "res",
    "Body": "res.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "err",
    "Body": "err (the second return value), it will be\ntreated as a run-time error, which will halt the execution (VM.Run() error)\nand will return the error to the user. All runtime type implementations, for\nexample, will return an ErrInvalidOperator error when the given operator is\nnot supported by the type.",
    "Desc": " (the second return value), it will be\ntreated as a run-time error, which will halt the execution (VM.Run() error)\nand will return the error to the user. All runtime type implementations, for\nexample, will return an ErrInvalidOperator error when the given operator is\nnot supported by the type."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "VM.Run() error",
    "Body": "VM.Run() error)\nand will return the error to the user. All runtime type implementations, for\nexample, will return an ErrInvalidOperator error when the given operator is\nnot supported by the type.",
    "Desc": ")\nand will return the error to the user. All runtime type implementations, for\nexample, will return an ErrInvalidOperator error when the given operator is\nnot supported by the type."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "ErrInvalidOperator",
    "Body": "ErrInvalidOperator error when the given operator is\nnot supported by the type.",
    "Desc": " error when the given operator is\nnot supported by the type."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "Error",
    "Body": "Error value as its result res\n(the first return value), which will not halt the runtime and will be treated\nlike any other values. As a dynamically typed language, the receiver (another\nexpression or statement) can determine how to translate Error value returned\nfrom binary operator expression.",
    "Desc": " value as its result res\n(the first return value), which will not halt the runtime and will be treated\nlike any other values. As a dynamically typed language, the receiver (another\nexpression or statement) can determine how to translate Error value returned\nfrom binary operator expression."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "res",
    "Body": "res\n(the first return value), which will not halt the runtime and will be treated\nlike any other values. As a dynamically typed language, the receiver (another\nexpression or statement) can determine how to translate Error value returned\nfrom binary operator expression.",
    "Desc": "\n(the first return value), which will not halt the runtime and will be treated\nlike any other values. As a dynamically typed language, the receiver (another\nexpression or statement) can determine how to translate Error value returned\nfrom binary operator expression."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "Error",
    "Body": "Error value returned\nfrom binary operator expression.",
    "Desc": " value returned\nfrom binary operator expression."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "o",
    "Body": "o. When comparing values of\ndifferent types, the runtime does not guarantee or force anything, but, it's\ngenerally a good idea to make the result consistent. For example, a custom\ninteger type may return true when comparing against String value, but, it\nshould return the same result for the same inputs.",
    "Desc": ". When comparing values of\ndifferent types, the runtime does not guarantee or force anything, but, it's\ngenerally a good idea to make the result consistent. For example, a custom\ninteger type may return true when comparing against String value, but, it\nshould return the same result for the same inputs."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "copy",
    "Body": "copy\nuses this method to copy values. Default implementation of all runtime types\nreturn a deep-copy values, but, it's not a requirement by the runtime.",
    "Desc": "\nuses this method to copy values. Default implementation of all runtime types\nreturn a deep-copy values, but, it's not a requirement by the runtime."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "IndexGet",
    "Body": "IndexGet returns an error (err), the VM will treat it as a run-time\nerror and ignore the returned value.",
    "Desc": " returns an error (err), the VM will treat it as a run-time\nerror and ignore the returned value."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "err",
    "Body": "err), the VM will treat it as a run-time\nerror and ignore the returned value.",
    "Desc": "), the VM will treat it as a run-time\nerror and ignore the returned value."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "Undefined",
    "Body": "Undefined value when the key does not exist. But, again, this is not a\nrequired behavior.",
    "Desc": " value when the key does not exist. But, again, this is not a\nrequired behavior."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "object.index = value",
    "Body": "object.index = value) and\nindexer (object[index] = value) in the assignment statements.",
    "Desc": ") and\nindexer (object[index] = value) in the assignment statements."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "object[index] = value",
    "Body": "object[index] = value) in the assignment statements.",
    "Desc": ") in the assignment statements."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "for-in",
    "Body": "for-in statements\n(for key, value in object { ... }). Two functions need to be implemented\nfor Iterable Objects",
    "Desc": " statements\n(for key, value in object { ... }). Two functions need to be implemented\nfor Iterable Objects"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "for key, value in object { ... }",
    "Body": "for key, value in object { ... }). Two functions need to be implemented\nfor Iterable Objects",
    "Desc": "). Two functions need to be implemented\nfor Iterable Objects"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "for-in",
    "Body": "for-in statements, the compiler uses Key and Value methods to populate\nthe current element's key (or index) and value from the object that this\niterator represents. The runtime will stop iterating in for-in statement\nwhen this method returns false.",
    "Desc": " statements, the compiler uses Key and Value methods to populate\nthe current element's key (or index) and value from the object that this\niterator represents. The runtime will stop iterating in for-in statement\nwhen this method returns false."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "for-in",
    "Body": "for-in statement\nwhen this method returns false.",
    "Desc": " statement\nwhen this method returns false."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "ObjectImpl",
    "Body": "ObjectImpl implementation. Tengo runtime will treat them in the\nsame way as its runtime types with no performance overhead.",
    "Desc": " implementation. Tengo runtime will treat them in the\nsame way as its runtime types with no performance overhead."
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "StringArray",
    "Body": "StringArray:",
    "Desc": ":"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "StringArray",
    "Body": "StringArray to the script:",
    "Desc": " to the script:"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "IndexGet",
    "Body": "IndexGet and IndexSet:",
    "Desc": " and IndexSet:"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "IndexSet",
    "Body": "IndexSet:",
    "Desc": ":"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "CanCall",
    "Body": "CanCall and Call:",
    "Desc": " and Call:"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "Call",
    "Body": "Call:",
    "Desc": ":"
  },
  {
    "Type": 0,
    "Module": "objects",
    "Object": "",
    "Code": "StringArray",
    "Body": "StringArray iterable:",
    "Desc": " iterable:"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(int) == (int) = (bool)",
    "Body": "(int) == (int) = (bool)Equality: equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(int) != (int) = (bool)",
    "Body": "(int) != (int) = (bool)Equality: inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) + (int) = (int)",
    "Body": "(int) + (int) = (int)Arithmetic Operators: sum",
    "Desc": ": sum"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) - (int) = (int)",
    "Body": "(int) - (int) = (int)Arithmetic Operators: difference",
    "Desc": ": difference"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) * (int) = (int)",
    "Body": "(int) * (int) = (int)Arithmetic Operators: product",
    "Desc": ": product"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) / (int) = (int)",
    "Body": "(int) / (int) = (int)Arithmetic Operators: quotient",
    "Desc": ": quotient"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) % (int) = (int)",
    "Body": "(int) % (int) = (int)Arithmetic Operators: remainder",
    "Desc": ": remainder"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) + (float) = (float)",
    "Body": "(int) + (float) = (float)Arithmetic Operators: sum",
    "Desc": ": sum"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) - (float) = (float)",
    "Body": "(int) - (float) = (float)Arithmetic Operators: difference",
    "Desc": ": difference"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) * (float) = (float)",
    "Body": "(int) * (float) = (float)Arithmetic Operators: product",
    "Desc": ": product"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) / (float) = (float)",
    "Body": "(int) / (float) = (float)Arithmetic Operators: quotient",
    "Desc": ": quotient"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) + (char) = (char)",
    "Body": "(int) + (char) = (char)Arithmetic Operators: sum",
    "Desc": ": sum"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(int) - (char) = (char)",
    "Body": "(int) - (char) = (char)Arithmetic Operators: difference",
    "Desc": ": difference"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Bitwise Operators",
    "Code": "(int) \u0026 (int) = (int)",
    "Body": "(int) \u0026 (int) = (int)Bitwise Operators: bitwise AND",
    "Desc": ": bitwise AND"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Bitwise Operators",
    "Code": "(int) | (int) = (int)",
    "Body": "(int) | (int) = (int)Bitwise Operators: bitwise OR",
    "Desc": ": bitwise OR"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Bitwise Operators",
    "Code": "(int) ^ (int) = (int)",
    "Body": "(int) ^ (int) = (int)Bitwise Operators: bitwise XOR",
    "Desc": ": bitwise XOR"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Bitwise Operators",
    "Code": "(int) \u0026^ (int) = (int)",
    "Body": "(int) \u0026^ (int) = (int)Bitwise Operators: bitclear (AND NOT)",
    "Desc": ": bitclear (AND NOT)"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Bitwise Operators",
    "Code": "(int) \u003c\u003c (int) = (int)",
    "Body": "(int) \u003c\u003c (int) = (int)Bitwise Operators: left shift",
    "Desc": ": left shift"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Bitwise Operators",
    "Code": "(int) \u003e\u003e (int) = (int)",
    "Body": "(int) \u003e\u003e (int) = (int)Bitwise Operators: right shift",
    "Desc": ": right shift"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003c (int) = (bool)",
    "Body": "(int) \u003c (int) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003e (int) = (bool)",
    "Body": "(int) \u003e (int) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003c= (int) = (bool)",
    "Body": "(int) \u003c= (int) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003e= (int) = (bool)",
    "Body": "(int) \u003e= (int) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003c (float) = (bool)",
    "Body": "(int) \u003c (float) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003e (float) = (bool)",
    "Body": "(int) \u003e (float) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003c= (float) = (bool)",
    "Body": "(int) \u003c= (float) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003e= (float) = (bool)",
    "Body": "(int) \u003e= (float) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003c (char) = (bool)",
    "Body": "(int) \u003c (char) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003e (char) = (bool)",
    "Body": "(int) \u003e (char) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003c= (char) = (bool)",
    "Body": "(int) \u003c= (char) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(int) \u003e= (char) = (bool)",
    "Body": "(int) \u003e= (char) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(float) == (float) = (bool)",
    "Body": "(float) == (float) = (bool)Equality: equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(float) != (float) = (bool)",
    "Body": "(float) != (float) = (bool)Equality: inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) + (float) = (float)",
    "Body": "(float) + (float) = (float)Arithmetic Operators: sum",
    "Desc": ": sum"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) - (float) = (float)",
    "Body": "(float) - (float) = (float)Arithmetic Operators: difference",
    "Desc": ": difference"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) * (float) = (float)",
    "Body": "(float) * (float) = (float)Arithmetic Operators: product",
    "Desc": ": product"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) / (float) = (float)",
    "Body": "(float) / (float) = (float)Arithmetic Operators: quotient",
    "Desc": ": quotient"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) + (int) = (int)",
    "Body": "(float) + (int) = (int)Arithmetic Operators: sum",
    "Desc": ": sum"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) - (int) = (int)",
    "Body": "(float) - (int) = (int)Arithmetic Operators: difference",
    "Desc": ": difference"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) * (int) = (int)",
    "Body": "(float) * (int) = (int)Arithmetic Operators: product",
    "Desc": ": product"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(float) / (int) = (int)",
    "Body": "(float) / (int) = (int)Arithmetic Operators: quotient",
    "Desc": ": quotient"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003c (float) = (bool)",
    "Body": "(float) \u003c (float) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003e (float) = (bool)",
    "Body": "(float) \u003e (float) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003c= (float) = (bool)",
    "Body": "(float) \u003c= (float) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003e= (float) = (bool)",
    "Body": "(float) \u003e= (float) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003c (int) = (bool)",
    "Body": "(float) \u003c (int) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003e (int) = (bool)",
    "Body": "(float) \u003e (int) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003c= (int) = (bool)",
    "Body": "(float) \u003c= (int) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(float) \u003e= (int) = (bool)",
    "Body": "(float) \u003e= (int) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(string) == (string) = (bool)",
    "Body": "(string) == (string) = (bool)Equality: equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(string) != (string) = (bool)",
    "Body": "(string) != (string) = (bool)Equality: inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Concatenation",
    "Code": "(string) + (string) = (string)",
    "Body": "(string) + (string) = (string)Concatenation: concatenation",
    "Desc": ": concatenation"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Concatenation",
    "Code": "(string) + (other types) = (string)",
    "Body": "(string) + (other types) = (string)Concatenation: concatenation (after string-converted)",
    "Desc": ": concatenation (after string-converted)"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(string) \u003c (string) = (bool)",
    "Body": "(string) \u003c (string) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(string) \u003e (string) = (bool)",
    "Body": "(string) \u003e (string) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(string) \u003c= (string) = (bool)",
    "Body": "(string) \u003c= (string) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(string) \u003e= (string) = (bool)",
    "Body": "(string) \u003e= (string) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(char) == (char) = (bool)",
    "Body": "(char) == (char) = (bool)Equality: equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(char) != (char) = (bool)",
    "Body": "(char) != (char) = (bool)Equality: inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(char) + (char) = (char)",
    "Body": "(char) + (char) = (char)Arithmetic Operators: sum",
    "Desc": ": sum"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(char) - (char) = (char)",
    "Body": "(char) - (char) = (char)Arithmetic Operators: difference",
    "Desc": ": difference"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(char) + (int) = (char)",
    "Body": "(char) + (int) = (char)Arithmetic Operators: sum",
    "Desc": ": sum"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(char) - (int) = (char)",
    "Body": "(char) - (int) = (char)Arithmetic Operators: difference",
    "Desc": ": difference"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003c (char) = (bool)",
    "Body": "(char) \u003c (char) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003e (char) = (bool)",
    "Body": "(char) \u003e (char) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003c= (char) = (bool)",
    "Body": "(char) \u003c= (char) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003e= (char) = (bool)",
    "Body": "(char) \u003e= (char) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003c (int) = (bool)",
    "Body": "(char) \u003c (int) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003e (int) = (bool)",
    "Body": "(char) \u003e (int) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003c= (int) = (bool)",
    "Body": "(char) \u003c= (int) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(char) \u003e= (int) = (bool)",
    "Body": "(char) \u003e= (int) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(bool) == (bool) = (bool)",
    "Body": "(bool) == (bool) = (bool)Equality: equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Equality",
    "Code": "(bool) != (bool) = (bool)",
    "Body": "(bool) != (bool) = (bool)Equality: inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(bytes) == (bytes) = (bool)",
    "Body": "(bytes) == (bytes) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(bytes) != (bytes) = (bool)",
    "Body": "(bytes) != (bytes) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(time) == (time) = (bool)",
    "Body": "(time) == (time) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(time) != (time) = (bool)",
    "Body": "(time) != (time) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(time) - (time) = (int)",
    "Body": "(time) - (time) = (int)Arithmetic Operators: difference in nanoseconds (duration)",
    "Desc": ": difference in nanoseconds (duration)"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(time) + (int) = (time)",
    "Body": "(time) + (int) = (time)Arithmetic Operators: time + duration (nanoseconds)",
    "Desc": ": time + duration (nanoseconds)"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Arithmetic Operators",
    "Code": "(time) - (int) = (time)",
    "Body": "(time) - (int) = (time)Arithmetic Operators: time - duration (nanoseconds)",
    "Desc": ": time - duration (nanoseconds)"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(time) \u003c (time) = (bool)",
    "Body": "(time) \u003c (time) = (bool)Comparison Operators: less than",
    "Desc": ": less than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(time) \u003e (time) = (bool)",
    "Body": "(time) \u003e (time) = (bool)Comparison Operators: greater than",
    "Desc": ": greater than"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(time) \u003c= (time) = (bool)",
    "Body": "(time) \u003c= (time) = (bool)Comparison Operators: less than or equal to",
    "Desc": ": less than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Comparison Operators",
    "Code": "(time) \u003e= (time) = (bool)",
    "Body": "(time) \u003e= (time) = (bool)Comparison Operators: greater than or equal to",
    "Desc": ": greater than or equal to"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(array) == (array) = (bool)",
    "Body": "(array) == (array) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(array) != (array) = (bool)",
    "Body": "(array) != (array) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(array) == (immutable-array) = (bool)",
    "Body": "(array) == (immutable-array) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(array) != (immutable-array) = (bool)",
    "Body": "(array) != (immutable-array) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-array) == (immutable-array) = (bool)",
    "Body": "(immutable-array) == (immutable-array) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-array) != (immutable-array) = (bool)",
    "Body": "(immutable-array) != (immutable-array) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-array) == (array) = (bool)",
    "Body": "(immutable-array) == (array) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-array) != (array) = (bool)",
    "Body": "(immutable-array) != (array) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "Concatenation",
    "Code": "(array) + (array)",
    "Body": "(array) + (array)Concatenation: return a concatenated array",
    "Desc": ": return a concatenated array"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(map) == (map) = (bool)",
    "Body": "(map) == (map) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(map) != (map) = (bool)",
    "Body": "(map) != (map) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(map) == (immutable-map) = (bool)",
    "Body": "(map) == (immutable-map) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(map) != (immutable-map) = (bool)",
    "Body": "(map) != (immutable-map) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-map) == (immutable-map) = (bool)",
    "Body": "(immutable-map) == (immutable-map) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-map) != (immutable-map) = (bool)",
    "Body": "(immutable-map) != (immutable-map) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-map) == (map) = (bool)",
    "Body": "(immutable-map) == (map) = (bool): equality",
    "Desc": ": equality"
  },
  {
    "Type": 0,
    "Module": "operators",
    "Object": "",
    "Code": "(immutable-map) != (map) = (bool)",
    "Body": "(immutable-map) != (map) = (bool): inequality",
    "Desc": ": inequality"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Tengo Runtime Types",
    "Code": "rune",
    "Body": "runeTengo Runtime Types in Go)",
    "Desc": " in Go)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Tengo Runtime Types",
    "Code": "[]byte",
    "Body": "[]byteTengo Runtime Types in Go)",
    "Desc": " in Go)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Tengo Runtime Types",
    "Code": "[]Object",
    "Body": "[]ObjectTengo Runtime Types in Go)",
    "Desc": " in Go)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Tengo Runtime Types",
    "Code": "[]Object",
    "Body": "[]ObjectTengo Runtime Types in Go)",
    "Desc": " in Go)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Tengo Runtime Types",
    "Code": "map[string]Object",
    "Body": "map[string]ObjectTengo Runtime Types in Go)",
    "Desc": " in Go)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Tengo Runtime Types",
    "Code": "map[string]Object",
    "Body": "map[string]ObjectTengo Runtime Types\nin Go)",
    "Desc": "\nin Go)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Tengo Runtime Types",
    "Code": "time.Time",
    "Body": "time.TimeTengo Runtime Types in Go)",
    "Desc": " in Go)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "Variable",
    "Body": "Variable will\nreturn zero values.",
    "Desc": " will\nreturn zero values."
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "strconv",
    "Body": "strconv package.",
    "Desc": " package."
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "Object.String()",
    "Body": "Object.String() function",
    "Desc": " function"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "time.Unix(v, 0)",
    "Body": "time.Unix(v, 0) to convert to Time",
    "Desc": " to convert to Time"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "Object.IsFalsy()",
    "Body": "Object.IsFalsy() interface method is used to determine if a given value\nshould evaluate to false (e.g. for condition expression of if statement).",
    "Desc": " interface method is used to determine if a given value\nshould evaluate to false (e.g. for condition expression of if statement)."
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "false",
    "Body": "false (e.g. for condition expression of if statement).",
    "Desc": " (e.g. for condition expression of if statement)."
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "if",
    "Body": "if statement).",
    "Desc": " statement)."
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "n == 0",
    "Body": "n == 0",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "len(s) == 0",
    "Body": "len(s) == 0",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "isNaN(f)",
    "Body": "isNaN(f)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "!b",
    "Body": "!b",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "c == 0",
    "Body": "c == 0",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "len(bytes) == 0",
    "Body": "len(bytes) == 0",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "len(arr) == 0",
    "Body": "len(arr) == 0",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "len(map) == 0",
    "Body": "len(map) == 0",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "Time.IsZero()",
    "Body": "Time.IsZero()",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "true",
    "Body": "true ",
    "Desc": " "
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "true",
    "Body": "true ",
    "Desc": " "
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "string(x)",
    "Body": "string(x)Type Conversion Builtin Functions: tries to convert x into string; returns undefined if failed",
    "Desc": ": tries to convert x into string; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "x",
    "Body": "xType Conversion Builtin Functions into string; returns undefined if failed",
    "Desc": " into string; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "undefined",
    "Body": "undefinedType Conversion Builtin Functions if failed",
    "Desc": " if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "int(x)",
    "Body": "int(x)Type Conversion Builtin Functions: tries to convert x into int; returns undefined if failed",
    "Desc": ": tries to convert x into int; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "x",
    "Body": "xType Conversion Builtin Functions into int; returns undefined if failed",
    "Desc": " into int; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "undefined",
    "Body": "undefinedType Conversion Builtin Functions if failed",
    "Desc": " if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "bool(x)",
    "Body": "bool(x)Type Conversion Builtin Functions: tries to convert x into bool; returns undefined if failed",
    "Desc": ": tries to convert x into bool; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "x",
    "Body": "xType Conversion Builtin Functions into bool; returns undefined if failed",
    "Desc": " into bool; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "undefined",
    "Body": "undefinedType Conversion Builtin Functions if failed",
    "Desc": " if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "float(x)",
    "Body": "float(x)Type Conversion Builtin Functions: tries to convert x into float; returns undefined if failed",
    "Desc": ": tries to convert x into float; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "x",
    "Body": "xType Conversion Builtin Functions into float; returns undefined if failed",
    "Desc": " into float; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "undefined",
    "Body": "undefinedType Conversion Builtin Functions if failed",
    "Desc": " if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "char(x)",
    "Body": "char(x)Type Conversion Builtin Functions: tries to convert x into char; returns undefined if failed",
    "Desc": ": tries to convert x into char; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "x",
    "Body": "xType Conversion Builtin Functions into char; returns undefined if failed",
    "Desc": " into char; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "undefined",
    "Body": "undefinedType Conversion Builtin Functions if failed",
    "Desc": " if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "bytes(x)",
    "Body": "bytes(x)Type Conversion Builtin Functions: tries to convert x into bytes; returns undefined if failed",
    "Desc": ": tries to convert x into bytes; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "x",
    "Body": "xType Conversion Builtin Functions into bytes; returns undefined if failed",
    "Desc": " into bytes; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "undefined",
    "Body": "undefinedType Conversion Builtin Functions if failed",
    "Desc": " if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "bytes(N)",
    "Body": "bytes(N): as a special case this will create a Bytes variable with the\ngiven size N (only if N is int)",
    "Desc": ": as a special case this will create a Bytes variable with the\ngiven size N (only if N is int)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "N",
    "Body": "N (only if N is int)",
    "Desc": " (only if N is int)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "",
    "Code": "N",
    "Body": "N is int)",
    "Desc": " is int)"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "time(x)",
    "Body": "time(x)Type Conversion Builtin Functions: tries to convert x into time; returns undefined if failed",
    "Desc": ": tries to convert x into time; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "x",
    "Body": "xType Conversion Builtin Functions into time; returns undefined if failed",
    "Desc": " into time; returns undefined if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Conversion Builtin Functions",
    "Code": "undefined",
    "Body": "undefinedType Conversion Builtin Functions if failed",
    "Desc": " if failed"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_string(x)",
    "Body": "is_string(x)Type Checking Builtin Functions: returns true if x is string; false otherwise",
    "Desc": ": returns true if x is string; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is string; false otherwise",
    "Desc": " if x is string; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is string; false otherwise",
    "Desc": " is string; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_int(x)",
    "Body": "is_int(x)Type Checking Builtin Functions: returns true if x is int; false otherwise",
    "Desc": ": returns true if x is int; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is int; false otherwise",
    "Desc": " if x is int; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is int; false otherwise",
    "Desc": " is int; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_bool(x)",
    "Body": "is_bool(x)Type Checking Builtin Functions: returns true if x is bool; false otherwise",
    "Desc": ": returns true if x is bool; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is bool; false otherwise",
    "Desc": " if x is bool; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is bool; false otherwise",
    "Desc": " is bool; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_float(x)",
    "Body": "is_float(x)Type Checking Builtin Functions: returns true if x is float; false otherwise",
    "Desc": ": returns true if x is float; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is float; false otherwise",
    "Desc": " if x is float; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is float; false otherwise",
    "Desc": " is float; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_char(x)",
    "Body": "is_char(x)Type Checking Builtin Functions: returns true if x is char; false otherwise",
    "Desc": ": returns true if x is char; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is char; false otherwise",
    "Desc": " if x is char; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is char; false otherwise",
    "Desc": " is char; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_bytes(x)",
    "Body": "is_bytes(x)Type Checking Builtin Functions: returns true if x is bytes; false otherwise",
    "Desc": ": returns true if x is bytes; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is bytes; false otherwise",
    "Desc": " if x is bytes; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is bytes; false otherwise",
    "Desc": " is bytes; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_array(x)",
    "Body": "is_array(x)Type Checking Builtin Functions: return true if x is array; false otherwise",
    "Desc": ": return true if x is array; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is array; false otherwise",
    "Desc": " if x is array; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is array; false otherwise",
    "Desc": " is array; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_immutable_array(x)",
    "Body": "is_immutable_array(x)Type Checking Builtin Functions: return true if x is immutable array; false\notherwise",
    "Desc": ": return true if x is immutable array; false\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is immutable array; false\notherwise",
    "Desc": " if x is immutable array; false\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is immutable array; false\notherwise",
    "Desc": " is immutable array; false\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions\notherwise",
    "Desc": "\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_map(x)",
    "Body": "is_map(x)Type Checking Builtin Functions: return true if x is map; false otherwise",
    "Desc": ": return true if x is map; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is map; false otherwise",
    "Desc": " if x is map; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is map; false otherwise",
    "Desc": " is map; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_immutable_map(x)",
    "Body": "is_immutable_map(x)Type Checking Builtin Functions: return true if x is immutable map; false\notherwise",
    "Desc": ": return true if x is immutable map; false\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is immutable map; false\notherwise",
    "Desc": " if x is immutable map; false\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is immutable map; false\notherwise",
    "Desc": " is immutable map; false\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions\notherwise",
    "Desc": "\notherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_time(x)",
    "Body": "is_time(x)Type Checking Builtin Functions: return true if x is time; false otherwise",
    "Desc": ": return true if x is time; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is time; false otherwise",
    "Desc": " if x is time; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is time; false otherwise",
    "Desc": " is time; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_error(x)",
    "Body": "is_error(x)Type Checking Builtin Functions: returns true if x is error; false otherwise",
    "Desc": ": returns true if x is error; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is error; false otherwise",
    "Desc": " if x is error; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is error; false otherwise",
    "Desc": " is error; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "is_undefined(x)",
    "Body": "is_undefined(x)Type Checking Builtin Functions: returns true if x is undefined; false otherwise",
    "Desc": ": returns true if x is undefined; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "true",
    "Body": "trueType Checking Builtin Functions if x is undefined; false otherwise",
    "Desc": " if x is undefined; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "x",
    "Body": "xType Checking Builtin Functions is undefined; false otherwise",
    "Desc": " is undefined; false otherwise"
  },
  {
    "Type": 0,
    "Module": "runtime-types",
    "Object": "Type Checking Builtin Functions",
    "Code": "false",
    "Body": "falseType Checking Builtin Functions otherwise",
    "Desc": " otherwise"
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "encode(src)",
    "Body": "encode(src)Functions: returns the base64 encoding of src.",
    "Desc": ": returns the base64 encoding of src."
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "decode(s)",
    "Body": "decode(s)Functions: returns the bytes represented by the base64 string s.",
    "Desc": ": returns the bytes represented by the base64 string s."
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "raw_encode(src)",
    "Body": "raw_encode(src)Functions: returns the base64 encoding of src but omits the padding.",
    "Desc": ": returns the base64 encoding of src but omits the padding."
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "raw_decode(s)",
    "Body": "raw_decode(s)Functions: returns the bytes represented by the base64 string s which\nomits the padding.",
    "Desc": ": returns the bytes represented by the base64 string s which\nomits the padding."
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "url_encode(src)",
    "Body": "url_encode(src)Functions: returns the url-base64 encoding of src.",
    "Desc": ": returns the url-base64 encoding of src."
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "url_decode(s)",
    "Body": "url_decode(s)Functions: returns the bytes represented by the url-base64 string s.",
    "Desc": ": returns the bytes represented by the url-base64 string s."
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "raw_url_encode(src)",
    "Body": "raw_url_encode(src)Functions: returns the url-base64 encoding of src but omits the\npadding.",
    "Desc": ": returns the url-base64 encoding of src but omits the\npadding."
  },
  {
    "Type": 0,
    "Module": "base64",
    "Object": "Functions",
    "Code": "raw_url_decode(s)",
    "Body": "raw_url_decode(s)Functions: returns the bytes represented by the url-base64 string\ns which omits the padding.",
    "Desc": ": returns the bytes represented by the url-base64 string\ns which omits the padding."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "all(x, fn) =\u003e bool",
    "Body": "all(x, fn) =\u003e boolFunctions: returns true if the given function fn evaluates to a\ntruthy value on all of the items in x. It returns undefined if x is not\nenumerable.",
    "Desc": ": returns true if the given function fn evaluates to a\ntruthy value on all of the items in x. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions evaluates to a\ntruthy value on all of the items in x. It returns undefined if x is not\nenumerable.",
    "Desc": " evaluates to a\ntruthy value on all of the items in x. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions. It returns undefined if x is not\nenumerable.",
    "Desc": ". It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not\nenumerable.",
    "Desc": " is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "any(x, fn) =\u003e bool",
    "Body": "any(x, fn) =\u003e boolFunctions: returns true if the given function fn evaluates to a\ntruthy value on any of the items in x. It returns undefined if x is not\nenumerable.",
    "Desc": ": returns true if the given function fn evaluates to a\ntruthy value on any of the items in x. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions evaluates to a\ntruthy value on any of the items in x. It returns undefined if x is not\nenumerable.",
    "Desc": " evaluates to a\ntruthy value on any of the items in x. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions. It returns undefined if x is not\nenumerable.",
    "Desc": ". It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not\nenumerable.",
    "Desc": " is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "chunk(x, size) =\u003e [object]",
    "Body": "chunk(x, size) =\u003e [object]Functions: returns an array of elements split into groups\nthe length of size. If x can't be split evenly, the final chunk will be the\nremaining elements. It returns undefined if x is not array.",
    "Desc": ": returns an array of elements split into groups\nthe length of size. If x can't be split evenly, the final chunk will be the\nremaining elements. It returns undefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions can't be split evenly, the final chunk will be the\nremaining elements. It returns undefined if x is not array.",
    "Desc": " can't be split evenly, the final chunk will be the\nremaining elements. It returns undefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not array.",
    "Desc": " is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "at(x, key) =\u003e object",
    "Body": "at(x, key) =\u003e objectFunctions: returns an element at the given index (if x is\narray) or key (if x is map). It returns undefined if x is not enumerable.",
    "Desc": ": returns an element at the given index (if x is\narray) or key (if x is map). It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is\narray) or key (if x is map). It returns undefined if x is not enumerable.",
    "Desc": " is\narray) or key (if x is map). It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is map). It returns undefined if x is not enumerable.",
    "Desc": " is map). It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not enumerable.",
    "Desc": " is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "each(x, fn)",
    "Body": "each(x, fn)Functions: iterates over elements of x and invokes fn for each\nelement. fn is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": ": iterates over elements of x and invokes fn for each\nelement. fn is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions and invokes fn for each\nelement. fn is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " and invokes fn for each\nelement. fn is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions for each\nelement. fn is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " for each\nelement. fn is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " is invoked with two arguments: key and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " and value. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "value",
    "Body": "valueFunctions. key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": ". key is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " is an\nint index if x is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " is array. key is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " is a string key if x is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is map. It does not\niterate and returns undefined if x is not enumerable.`",
    "Desc": " is map. It does not\niterate and returns undefined if x is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not enumerable.`",
    "Desc": " is not enumerable.`"
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "filter(x, fn) =\u003e [object]",
    "Body": "filter(x, fn) =\u003e [object]Functions: iterates over elements of x, returning an\narray of all elements fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array.",
    "Desc": ": iterates over elements of x, returning an\narray of all elements fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions, returning an\narray of all elements fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array.",
    "Desc": ", returning an\narray of all elements fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array.",
    "Desc": " returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array.",
    "Desc": " is invoked with two\narguments: key and value. key is an int index if x is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions and value. key is an int index if x is array. It returns\nundefined if x is not array.",
    "Desc": " and value. key is an int index if x is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "value",
    "Body": "valueFunctions. key is an int index if x is array. It returns\nundefined if x is not array.",
    "Desc": ". key is an int index if x is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is an int index if x is array. It returns\nundefined if x is not array.",
    "Desc": " is an int index if x is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is array. It returns\nundefined if x is not array.",
    "Desc": " is array. It returns\nundefined if x is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not array.",
    "Desc": " is not array."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "find(x, fn) =\u003e object",
    "Body": "find(x, fn) =\u003e objectFunctions: iterates over elements of x, returning value of\nthe first element fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": ": iterates over elements of x, returning value of\nthe first element fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions, returning value of\nthe first element fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": ", returning value of\nthe first element fn returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": " returns truthy for. fn is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": " is invoked with two\narguments: key and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": " and value. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "value",
    "Body": "valueFunctions. key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": ". key is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": " is an int index if x is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is array. key is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": " is array. key is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is\na string key if x is map. It returns undefined if x is not enumerable.",
    "Desc": " is\na string key if x is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is map. It returns undefined if x is not enumerable.",
    "Desc": " is map. It returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not enumerable.",
    "Desc": " is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "find_key(x, fn) =\u003e int/string",
    "Body": "find_key(x, fn) =\u003e int/stringFunctions: iterates over elements of x, returning key\nor index of the first element fn returns truthy for. fn is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": ": iterates over elements of x, returning key\nor index of the first element fn returns truthy for. fn is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions, returning key\nor index of the first element fn returns truthy for. fn is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": ", returning key\nor index of the first element fn returns truthy for. fn is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions returns truthy for. fn is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": " returns truthy for. fn is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": " is invoked with\ntwo arguments: key and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": " and value. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "value",
    "Body": "valueFunctions. key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": ". key is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": " is an int index if x is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": " is array.\nkey is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is a string key if x is map. It returns undefined if x is not\nenumerable.",
    "Desc": " is a string key if x is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is map. It returns undefined if x is not\nenumerable.",
    "Desc": " is map. It returns undefined if x is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not\nenumerable.",
    "Desc": " is not\nenumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "map(x, fn) =\u003e [object]",
    "Body": "map(x, fn) =\u003e [object]Functions: creates an array of values by running each element\nin x through fn. fn is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": ": creates an array of values by running each element\nin x through fn. fn is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions through fn. fn is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": " through fn. fn is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions. fn is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": ". fn is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "fn",
    "Body": "fnFunctions is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": " is invoked with two arguments: key and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": " and value.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "value",
    "Body": "valueFunctions.\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": ".\nkey is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": " is an int index if x is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": " is array. key is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key",
    "Body": "keyFunctions is a string key if x is map.\nIt returns undefined if x is not enumerable.",
    "Desc": " is a string key if x is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is map.\nIt returns undefined if x is not enumerable.",
    "Desc": " is map.\nIt returns undefined if x is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "x",
    "Body": "xFunctions is not enumerable.",
    "Desc": " is not enumerable."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "key(k, _) =\u003e object",
    "Body": "key(k, _) =\u003e objectFunctions: returns the first argument.",
    "Desc": ": returns the first argument."
  },
  {
    "Type": 0,
    "Module": "enum",
    "Object": "Functions",
    "Code": "value(_, v) =\u003e object",
    "Body": "value(_, v) =\u003e objectFunctions: returns the second argument.",
    "Desc": ": returns the second argument."
  },
  {
    "Type": 0,
    "Module": "fmt",
    "Object": "Functions",
    "Code": "print(args...)",
    "Body": "print(args...)Functions: Prints a string representation of the given variable to the\nstandard output. Unlike Go's fmt.Print function, no spaces are added between\nthe operands.",
    "Desc": ": Prints a string representation of the given variable to the\nstandard output. Unlike Go's fmt.Print function, no spaces are added between\nthe operands."
  },
  {
    "Type": 0,
    "Module": "fmt",
    "Object": "Functions",
    "Code": "fmt.Print",
    "Body": "fmt.PrintFunctions function, no spaces are added between\nthe operands.",
    "Desc": " function, no spaces are added between\nthe operands."
  },
  {
    "Type": 0,
    "Module": "fmt",
    "Object": "Functions",
    "Code": "println(args...)",
    "Body": "println(args...)Functions: Prints a string representation of the given variable to\nthe standard output with a newline appended. Unlike Go's fmt.Println\nfunction, no spaces are added between the operands.",
    "Desc": ": Prints a string representation of the given variable to\nthe standard output with a newline appended. Unlike Go's fmt.Println\nfunction, no spaces are added between the operands."
  },
  {
    "Type": 0,
    "Module": "fmt",
    "Object": "Functions",
    "Code": "fmt.Println",
    "Body": "fmt.PrintlnFunctions\nfunction, no spaces are added between the operands.",
    "Desc": "\nfunction, no spaces are added between the operands."
  },
  {
    "Type": 0,
    "Module": "fmt",
    "Object": "Functions",
    "Code": "printf(format, args...)",
    "Body": "printf(format, args...)Functions: Prints a formatted string to the standard output.\nIt does not append the newline character at the end. The first argument must\na String object. See\n for more\ndetails on formatting.",
    "Desc": ": Prints a formatted string to the standard output.\nIt does not append the newline character at the end. The first argument must\na String object. See\n for more\ndetails on formatting."
  },
  {
    "Type": 0,
    "Module": "fmt",
    "Object": "Functions",
    "Code": "sprintf(format, args...)",
    "Body": "sprintf(format, args...)Functions: Returns a formatted string. Alias of the builtin\nfunction format. The first argument must be a String object. See\n for more\ndetails on formatting.",
    "Desc": ": Returns a formatted string. Alias of the builtin\nfunction format. The first argument must be a String object. See\n for more\ndetails on formatting."
  },
  {
    "Type": 0,
    "Module": "fmt",
    "Object": "Functions",
    "Code": "format",
    "Body": "formatFunctions. The first argument must be a String object. See\n for more\ndetails on formatting.",
    "Desc": ". The first argument must be a String object. See\n for more\ndetails on formatting."
  },
  {
    "Type": 0,
    "Module": "hex",
    "Object": "Functions",
    "Code": "encode(src)",
    "Body": "encode(src)Functions: returns the hexadecimal encoding of src.",
    "Desc": ": returns the hexadecimal encoding of src."
  },
  {
    "Type": 0,
    "Module": "hex",
    "Object": "Functions",
    "Code": "decode(s)",
    "Body": "decode(s)Functions: returns the bytes represented by the hexadecimal string s.",
    "Desc": ": returns the bytes represented by the hexadecimal string s."
  },
  {
    "Type": 0,
    "Module": "json",
    "Object": "Functions",
    "Code": "decode(b string/bytes) =\u003e object",
    "Body": "decode(b string/bytes) =\u003e objectFunctions: Parses the JSON string and returns an\nobject.",
    "Desc": ": Parses the JSON string and returns an\nobject."
  },
  {
    "Type": 0,
    "Module": "json",
    "Object": "Functions",
    "Code": "encode(o object) =\u003e bytes",
    "Body": "encode(o object) =\u003e bytesFunctions: Returns the JSON string (bytes) of the object.\nUnlike Go's JSON package, this function does not HTML-escape texts, but, one\ncan use html_escape function if needed.",
    "Desc": ": Returns the JSON string (bytes) of the object.\nUnlike Go's JSON package, this function does not HTML-escape texts, but, one\ncan use html_escape function if needed."
  },
  {
    "Type": 0,
    "Module": "json",
    "Object": "Functions",
    "Code": "html_escape",
    "Body": "html_escapeFunctions function if needed.",
    "Desc": " function if needed."
  },
  {
    "Type": 0,
    "Module": "json",
    "Object": "Functions",
    "Code": "indent(b string/bytes) =\u003e bytes",
    "Body": "indent(b string/bytes) =\u003e bytesFunctions: Returns an indented form of input JSON\nbytes string.",
    "Desc": ": Returns an indented form of input JSON\nbytes string."
  },
  {
    "Type": 0,
    "Module": "json",
    "Object": "Functions",
    "Code": "html_escape(b string/bytes) =\u003e bytes",
    "Body": "html_escape(b string/bytes) =\u003e bytesFunctions: Return an HTML-safe form of input\nJSON bytes string.",
    "Desc": ": Return an HTML-safe form of input\nJSON bytes string."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "e",
    "Body": "eConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "pi",
    "Body": "piConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "phi",
    "Body": "phiConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "sqrt2",
    "Body": "sqrt2Constants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "sqrtE",
    "Body": "sqrtEConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "sprtPi",
    "Body": "sprtPiConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "sqrtPhi",
    "Body": "sqrtPhiConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "ln2",
    "Body": "ln2Constants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "log2E",
    "Body": "log2EConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "ln10",
    "Body": "ln10Constants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Constants",
    "Code": "ln10E",
    "Body": "ln10EConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "abs(x float) =\u003e float",
    "Body": "abs(x float) =\u003e floatFunctions: returns the absolute value of x.",
    "Desc": ": returns the absolute value of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "acos(x float) =\u003e float",
    "Body": "acos(x float) =\u003e floatFunctions: returns the arccosine, in radians, of x.",
    "Desc": ": returns the arccosine, in radians, of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "acosh(x float) =\u003e float",
    "Body": "acosh(x float) =\u003e floatFunctions: returns the inverse hyperbolic cosine of x.",
    "Desc": ": returns the inverse hyperbolic cosine of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "asin(x float) =\u003e float",
    "Body": "asin(x float) =\u003e floatFunctions: returns the arcsine, in radians, of x.",
    "Desc": ": returns the arcsine, in radians, of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "asinh(x float) =\u003e float",
    "Body": "asinh(x float) =\u003e floatFunctions: returns the inverse hyperbolic sine of x.",
    "Desc": ": returns the inverse hyperbolic sine of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "atan(x float) =\u003e float",
    "Body": "atan(x float) =\u003e floatFunctions: returns the arctangent, in radians, of x.",
    "Desc": ": returns the arctangent, in radians, of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "atan2(y float, xfloat) =\u003e float",
    "Body": "atan2(y float, xfloat) =\u003e floatFunctions: returns the arc tangent of y/x, using the\nsigns of the two to determine the quadrant of the return value.",
    "Desc": ": returns the arc tangent of y/x, using the\nsigns of the two to determine the quadrant of the return value."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "atanh(x float) =\u003e float",
    "Body": "atanh(x float) =\u003e floatFunctions: returns the inverse hyperbolic tangent of x.",
    "Desc": ": returns the inverse hyperbolic tangent of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "cbrt(x float) =\u003e float",
    "Body": "cbrt(x float) =\u003e floatFunctions: returns the cube root of x.",
    "Desc": ": returns the cube root of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "ceil(x float) =\u003e float",
    "Body": "ceil(x float) =\u003e floatFunctions: returns the least integer value greater than or\nequal to x.",
    "Desc": ": returns the least integer value greater than or\nequal to x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "copysign(x float, y float) =\u003e float",
    "Body": "copysign(x float, y float) =\u003e floatFunctions: returns a value with the magnitude of\nx and the sign of y.",
    "Desc": ": returns a value with the magnitude of\nx and the sign of y."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "cos(x float) =\u003e float",
    "Body": "cos(x float) =\u003e floatFunctions: returns the cosine of the radian argument x.",
    "Desc": ": returns the cosine of the radian argument x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "cosh(x float) =\u003e float",
    "Body": "cosh(x float) =\u003e floatFunctions: returns the hyperbolic cosine of x.",
    "Desc": ": returns the hyperbolic cosine of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "dim(x float, y float) =\u003e float",
    "Body": "dim(x float, y float) =\u003e floatFunctions: returns the maximum of x-y or 0.",
    "Desc": ": returns the maximum of x-y or 0."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "erf(x float) =\u003e float",
    "Body": "erf(x float) =\u003e floatFunctions: returns the error function of x.",
    "Desc": ": returns the error function of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "erfc(x float) =\u003e float",
    "Body": "erfc(x float) =\u003e floatFunctions: returns the complementary error function of x.",
    "Desc": ": returns the complementary error function of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "exp(x float) =\u003e float",
    "Body": "exp(x float) =\u003e floatFunctions: returns e**x, the base-e exponential of x.",
    "Desc": ": returns e**x, the base-e exponential of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "exp2(x float) =\u003e float",
    "Body": "exp2(x float) =\u003e floatFunctions: returns 2**x, the base-2 exponential of x.",
    "Desc": ": returns 2**x, the base-2 exponential of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "expm1(x float) =\u003e float",
    "Body": "expm1(x float) =\u003e floatFunctions: returns e**x - 1, the base-e exponential of x\nminus 1. It is more accurate than Exp(x) - 1 when x is near zero.",
    "Desc": ": returns e**x - 1, the base-e exponential of x\nminus 1. It is more accurate than Exp(x) - 1 when x is near zero."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "floor(x float) =\u003e float",
    "Body": "floor(x float) =\u003e floatFunctions: returns the greatest integer value less than or\nequal to x.",
    "Desc": ": returns the greatest integer value less than or\nequal to x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "gamma(x float) =\u003e float",
    "Body": "gamma(x float) =\u003e floatFunctions: returns the Gamma function of x.",
    "Desc": ": returns the Gamma function of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "hypot(p float, q float) =\u003e float",
    "Body": "hypot(p float, q float) =\u003e floatFunctions: returns Sqrt(p * p + q * q), taking care\nto avoid unnecessary overflow and underflow.",
    "Desc": ": returns Sqrt(p * p + q * q), taking care\nto avoid unnecessary overflow and underflow."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "Sqrt(p * p + q * q)",
    "Body": "Sqrt(p * p + q * q)Functions, taking care\nto avoid unnecessary overflow and underflow.",
    "Desc": ", taking care\nto avoid unnecessary overflow and underflow."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "ilogb(x float) =\u003e float",
    "Body": "ilogb(x float) =\u003e floatFunctions: returns the binary exponent of x as an integer.",
    "Desc": ": returns the binary exponent of x as an integer."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "inf(sign int) =\u003e float",
    "Body": "inf(sign int) =\u003e floatFunctions: returns positive infinity if sign \u003e= 0, negative\ninfinity if sign \u003c 0.",
    "Desc": ": returns positive infinity if sign \u003e= 0, negative\ninfinity if sign \u003c 0."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "is_inf(f float, sign int) =\u003e float",
    "Body": "is_inf(f float, sign int) =\u003e floatFunctions: reports whether f is an infinity,\naccording to sign. If sign \u003e 0, IsInf reports whether f is positive infinity.\nIf sign \u003c 0, IsInf reports whether f is negative infinity. If sign == 0,\nIsInf reports whether f is either infinity.",
    "Desc": ": reports whether f is an infinity,\naccording to sign. If sign \u003e 0, IsInf reports whether f is positive infinity.\nIf sign \u003c 0, IsInf reports whether f is negative infinity. If sign == 0,\nIsInf reports whether f is either infinity."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "is_nan(f float) =\u003e float",
    "Body": "is_nan(f float) =\u003e floatFunctions: reports whether f is an IEEE 754 ``not-a-number''\nvalue.",
    "Desc": ": reports whether f is an IEEE 754 ``not-a-number''\nvalue."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "j0(x float) =\u003e float",
    "Body": "j0(x float) =\u003e floatFunctions: returns the order-zero Bessel function of the first\nkind.",
    "Desc": ": returns the order-zero Bessel function of the first\nkind."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "j1(x float) =\u003e float",
    "Body": "j1(x float) =\u003e floatFunctions: returns the order-one Bessel function of the first\nkind.",
    "Desc": ": returns the order-one Bessel function of the first\nkind."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "jn(n int, x float) =\u003e float",
    "Body": "jn(n int, x float) =\u003e floatFunctions: returns the order-n Bessel function of the\nfirst kind.",
    "Desc": ": returns the order-n Bessel function of the\nfirst kind."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "ldexp(frac float, exp int) =\u003e float",
    "Body": "ldexp(frac float, exp int) =\u003e floatFunctions: is the inverse of frexp. It returns\nfrac × 2**exp.",
    "Desc": ": is the inverse of frexp. It returns\nfrac × 2**exp."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "log(x float) =\u003e float",
    "Body": "log(x float) =\u003e floatFunctions: returns the natural logarithm of x.",
    "Desc": ": returns the natural logarithm of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "log10(x float) =\u003e float",
    "Body": "log10(x float) =\u003e floatFunctions: returns the decimal logarithm of x.",
    "Desc": ": returns the decimal logarithm of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "log1p(x float) =\u003e float",
    "Body": "log1p(x float) =\u003e floatFunctions: returns the natural logarithm of 1 plus its\nargument x. It is more accurate than Log(1 + x) when x is near zero.",
    "Desc": ": returns the natural logarithm of 1 plus its\nargument x. It is more accurate than Log(1 + x) when x is near zero."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "log2(x float) =\u003e float",
    "Body": "log2(x float) =\u003e floatFunctions: returns the binary logarithm of x.",
    "Desc": ": returns the binary logarithm of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "logb(x float) =\u003e float",
    "Body": "logb(x float) =\u003e floatFunctions: returns the binary exponent of x.",
    "Desc": ": returns the binary exponent of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "max(x float, y float) =\u003e float",
    "Body": "max(x float, y float) =\u003e floatFunctions: returns the larger of x or y.",
    "Desc": ": returns the larger of x or y."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "min(x float, y float) =\u003e float",
    "Body": "min(x float, y float) =\u003e floatFunctions: returns the smaller of x or y.",
    "Desc": ": returns the smaller of x or y."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "mod(x float, y float) =\u003e float",
    "Body": "mod(x float, y float) =\u003e floatFunctions: returns the floating-point remainder of x/y.",
    "Desc": ": returns the floating-point remainder of x/y."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "nan() =\u003e float",
    "Body": "nan() =\u003e floatFunctions: returns an IEEE 754 ``not-a-number'' value.",
    "Desc": ": returns an IEEE 754 ``not-a-number'' value."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "nextafter(x float, y float) =\u003e float",
    "Body": "nextafter(x float, y float) =\u003e floatFunctions: returns the next representable\nfloat64 value after x towards y.",
    "Desc": ": returns the next representable\nfloat64 value after x towards y."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "pow(x float, y float) =\u003e float",
    "Body": "pow(x float, y float) =\u003e floatFunctions: returns x**y, the base-x exponential of y.",
    "Desc": ": returns x**y, the base-x exponential of y."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "pow10(n int) =\u003e float",
    "Body": "pow10(n int) =\u003e floatFunctions: returns 10**n, the base-10 exponential of n.",
    "Desc": ": returns 10**n, the base-10 exponential of n."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "remainder(x float, y float) =\u003e float",
    "Body": "remainder(x float, y float) =\u003e floatFunctions: returns the IEEE 754 floating-point\nremainder of x/y.",
    "Desc": ": returns the IEEE 754 floating-point\nremainder of x/y."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "signbit(x float) =\u003e float",
    "Body": "signbit(x float) =\u003e floatFunctions: returns true if x is negative or negative zero.",
    "Desc": ": returns true if x is negative or negative zero."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "sin(x float) =\u003e float",
    "Body": "sin(x float) =\u003e floatFunctions: returns the sine of the radian argument x.",
    "Desc": ": returns the sine of the radian argument x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "sinh(x float) =\u003e float",
    "Body": "sinh(x float) =\u003e floatFunctions: returns the hyperbolic sine of x.",
    "Desc": ": returns the hyperbolic sine of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "sqrt(x float) =\u003e float",
    "Body": "sqrt(x float) =\u003e floatFunctions: returns the square root of x.",
    "Desc": ": returns the square root of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "tan(x float) =\u003e float",
    "Body": "tan(x float) =\u003e floatFunctions: returns the tangent of the radian argument x.",
    "Desc": ": returns the tangent of the radian argument x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "tanh(x float) =\u003e float",
    "Body": "tanh(x float) =\u003e floatFunctions: returns the hyperbolic tangent of x.",
    "Desc": ": returns the hyperbolic tangent of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "trunc(x float) =\u003e float",
    "Body": "trunc(x float) =\u003e floatFunctions: returns the integer value of x.",
    "Desc": ": returns the integer value of x."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "y0(x float) =\u003e float",
    "Body": "y0(x float) =\u003e floatFunctions: returns the order-zero Bessel function of the second\nkind.",
    "Desc": ": returns the order-zero Bessel function of the second\nkind."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "y1(x float) =\u003e float",
    "Body": "y1(x float) =\u003e floatFunctions: returns the order-one Bessel function of the second\nkind.",
    "Desc": ": returns the order-one Bessel function of the second\nkind."
  },
  {
    "Type": 0,
    "Module": "math",
    "Object": "Functions",
    "Code": "yn(n int, x float) =\u003e float",
    "Body": "yn(n int, x float) =\u003e floatFunctions: returns the order-n Bessel function of the\nsecond kind.",
    "Desc": ": returns the order-n Bessel function of the\nsecond kind."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_rdonly",
    "Body": "o_rdonlyConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_wronly",
    "Body": "o_wronlyConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_rdwr",
    "Body": "o_rdwrConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_append",
    "Body": "o_appendConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_create",
    "Body": "o_createConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_excl",
    "Body": "o_exclConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_sync",
    "Body": "o_syncConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "o_trunc",
    "Body": "o_truncConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_dir",
    "Body": "mode_dirConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_append",
    "Body": "mode_appendConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_exclusive",
    "Body": "mode_exclusiveConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_temporary",
    "Body": "mode_temporaryConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_symlink",
    "Body": "mode_symlinkConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_device",
    "Body": "mode_deviceConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_named_pipe",
    "Body": "mode_named_pipeConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_socket",
    "Body": "mode_socketConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_setuid",
    "Body": "mode_setuidConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_setgui",
    "Body": "mode_setguiConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_char_device",
    "Body": "mode_char_deviceConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_sticky",
    "Body": "mode_stickyConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_irregular",
    "Body": "mode_irregularConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_type",
    "Body": "mode_typeConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "mode_perm",
    "Body": "mode_permConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "seek_set",
    "Body": "seek_setConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "seek_cur",
    "Body": "seek_curConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "seek_end",
    "Body": "seek_endConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "path_separator",
    "Body": "path_separatorConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "path_list_separator",
    "Body": "path_list_separatorConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Constants",
    "Code": "dev_null",
    "Body": "dev_nullConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "args() =\u003e [string]",
    "Body": "args() =\u003e [string]Functions: returns command-line arguments, starting with the\nprogram name.",
    "Desc": ": returns command-line arguments, starting with the\nprogram name."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "chdir(dir string) =\u003e error",
    "Body": "chdir(dir string) =\u003e errorFunctions: changes the current working directory to the\nnamed directory.",
    "Desc": ": changes the current working directory to the\nnamed directory."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "chmod(name string, mode int) =\u003e error",
    "Body": "chmod(name string, mode int) =\u003e errorFunctions: changes the mode of the named file\nto mode.",
    "Desc": ": changes the mode of the named file\nto mode."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "chown(name string, uid int, gid int) =\u003e error",
    "Body": "chown(name string, uid int, gid int) =\u003e errorFunctions: changes the numeric uid and\ngid of the named file.",
    "Desc": ": changes the numeric uid and\ngid of the named file."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "clearenv()",
    "Body": "clearenv()Functions: deletes all environment variables.",
    "Desc": ": deletes all environment variables."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "environ() =\u003e [string]",
    "Body": "environ() =\u003e [string]Functions: returns a copy of strings representing the\nenvironment.",
    "Desc": ": returns a copy of strings representing the\nenvironment."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "exit(code int)",
    "Body": "exit(code int)Functions: causes the current program to exit with the given status\ncode.",
    "Desc": ": causes the current program to exit with the given status\ncode."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "expand_env(s string) =\u003e string",
    "Body": "expand_env(s string) =\u003e stringFunctions: replaces var in the string\naccording to the values of the current environment variables.",
    "Desc": ": replaces var in the string\naccording to the values of the current environment variables."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getegid() =\u003e int",
    "Body": "getegid() =\u003e intFunctions: returns the numeric effective group id of the caller.",
    "Desc": ": returns the numeric effective group id of the caller."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getenv(key string) =\u003e string",
    "Body": "getenv(key string) =\u003e stringFunctions: retrieves the value of the environment\nvariable named by the key.",
    "Desc": ": retrieves the value of the environment\nvariable named by the key."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "geteuid() =\u003e int",
    "Body": "geteuid() =\u003e intFunctions: returns the numeric effective user id of the caller.",
    "Desc": ": returns the numeric effective user id of the caller."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getgid() =\u003e int",
    "Body": "getgid() =\u003e intFunctions: returns the numeric group id of the caller.",
    "Desc": ": returns the numeric group id of the caller."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getgroups() =\u003e [int]/error",
    "Body": "getgroups() =\u003e [int]/errorFunctions: returns a list of the numeric ids of groups\nthat the caller belongs to.",
    "Desc": ": returns a list of the numeric ids of groups\nthat the caller belongs to."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getpagesize() =\u003e int",
    "Body": "getpagesize() =\u003e intFunctions: returns the underlying system's memory page size.",
    "Desc": ": returns the underlying system's memory page size."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getpid() =\u003e int",
    "Body": "getpid() =\u003e intFunctions: returns the process id of the caller.",
    "Desc": ": returns the process id of the caller."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getppid() =\u003e int",
    "Body": "getppid() =\u003e intFunctions: returns the process id of the caller's parent.",
    "Desc": ": returns the process id of the caller's parent."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getuid() =\u003e int",
    "Body": "getuid() =\u003e intFunctions: returns the numeric user id of the caller.",
    "Desc": ": returns the numeric user id of the caller."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "getwd() =\u003e string/error",
    "Body": "getwd() =\u003e string/errorFunctions: returns a rooted path name corresponding to the\ncurrent directory.",
    "Desc": ": returns a rooted path name corresponding to the\ncurrent directory."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "hostname() =\u003e string/error",
    "Body": "hostname() =\u003e string/errorFunctions: returns the host name reported by the kernel.",
    "Desc": ": returns the host name reported by the kernel."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "lchown(name string, uid int, gid int) =\u003e error",
    "Body": "lchown(name string, uid int, gid int) =\u003e errorFunctions: changes the numeric uid\nand gid of the named file.",
    "Desc": ": changes the numeric uid\nand gid of the named file."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "link(oldname string, newname string) =\u003e error",
    "Body": "link(oldname string, newname string) =\u003e errorFunctions: creates newname as a hard\nlink to the oldname file.",
    "Desc": ": creates newname as a hard\nlink to the oldname file."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "lookup_env(key string) =\u003e string/false",
    "Body": "lookup_env(key string) =\u003e string/falseFunctions: retrieves the value of the\nenvironment variable named by the key.",
    "Desc": ": retrieves the value of the\nenvironment variable named by the key."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "mkdir(name string, perm int) =\u003e error",
    "Body": "mkdir(name string, perm int) =\u003e errorFunctions: creates a new directory with the\nspecified name and permission bits (before umask).",
    "Desc": ": creates a new directory with the\nspecified name and permission bits (before umask)."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "mkdir_all(name string, perm int) =\u003e error",
    "Body": "mkdir_all(name string, perm int) =\u003e errorFunctions: creates a directory named path,\nalong with any necessary parents, and returns nil, or else returns an error.",
    "Desc": ": creates a directory named path,\nalong with any necessary parents, and returns nil, or else returns an error."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "read_file(name string) =\u003e bytes/error",
    "Body": "read_file(name string) =\u003e bytes/errorFunctions: reads the contents of a file into\na byte array",
    "Desc": ": reads the contents of a file into\na byte array"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "readlink(name string) =\u003e string/error",
    "Body": "readlink(name string) =\u003e string/errorFunctions: returns the destination of the\nnamed symbolic link.",
    "Desc": ": returns the destination of the\nnamed symbolic link."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "remove(name string) =\u003e error",
    "Body": "remove(name string) =\u003e errorFunctions: removes the named file or (empty) directory.",
    "Desc": ": removes the named file or (empty) directory."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "remove_all(name string) =\u003e error",
    "Body": "remove_all(name string) =\u003e errorFunctions: removes path and any children it\ncontains.",
    "Desc": ": removes path and any children it\ncontains."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "rename(oldpath string, newpath string) =\u003e error",
    "Body": "rename(oldpath string, newpath string) =\u003e errorFunctions: renames (moves) oldpath\nto newpath.",
    "Desc": ": renames (moves) oldpath\nto newpath."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "setenv(key string, value string) =\u003e error",
    "Body": "setenv(key string, value string) =\u003e errorFunctions: sets the value of the\nenvironment variable named by the key.",
    "Desc": ": sets the value of the\nenvironment variable named by the key."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "stat(filename string) =\u003e FileInfo/error",
    "Body": "stat(filename string) =\u003e FileInfo/errorFunctions: returns a file info structure\ndescribing the file",
    "Desc": ": returns a file info structure\ndescribing the file"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "symlink(oldname string newname string) =\u003e error",
    "Body": "symlink(oldname string newname string) =\u003e errorFunctions: creates newname as a\nsymbolic link to oldname.",
    "Desc": ": creates newname as a\nsymbolic link to oldname."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "temp_dir() =\u003e string",
    "Body": "temp_dir() =\u003e stringFunctions: returns the default directory to use for temporary\nfiles.",
    "Desc": ": returns the default directory to use for temporary\nfiles."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "truncate(name string, size int) =\u003e error",
    "Body": "truncate(name string, size int) =\u003e errorFunctions: changes the size of the named\nfile.",
    "Desc": ": changes the size of the named\nfile."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "unsetenv(key string) =\u003e error",
    "Body": "unsetenv(key string) =\u003e errorFunctions: unsets a single environment variable.",
    "Desc": ": unsets a single environment variable."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "create(name string) =\u003e File/error",
    "Body": "create(name string) =\u003e File/errorFunctions: creates the named file with mode 0666\n(before umask), truncating it if it already exists.",
    "Desc": ": creates the named file with mode 0666\n(before umask), truncating it if it already exists."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "open(name string) =\u003e File/error",
    "Body": "open(name string) =\u003e File/errorFunctions: opens the named file for reading. If\nsuccessful, methods on the returned file can be used for reading; the\nassociated file descriptor has mode O_RDONLY.",
    "Desc": ": opens the named file for reading. If\nsuccessful, methods on the returned file can be used for reading; the\nassociated file descriptor has mode O_RDONLY."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "open_file(name string, flag int, perm int) =\u003e File/error",
    "Body": "open_file(name string, flag int, perm int) =\u003e File/errorFunctions: is the\ngeneralized open call; most users will use Open or Create instead. It opens\nthe named file with specified flag (O_RDONLY etc.) and perm (before umask),\nif applicable.",
    "Desc": ": is the\ngeneralized open call; most users will use Open or Create instead. It opens\nthe named file with specified flag (O_RDONLY etc.) and perm (before umask),\nif applicable."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "find_process(pid int) =\u003e Process/error",
    "Body": "find_process(pid int) =\u003e Process/errorFunctions: looks for a running process by its\npid.",
    "Desc": ": looks for a running process by its\npid."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "start_process(name string, argv [string], dir string, env [string]) =\u003e Process/error",
    "Body": "start_process(name string, argv [string], dir string, env [string]) =\u003e Process/errorFunctions:\nstarts a new process with the program, arguments and attributes specified by\nname, argv and attr. The argv slice will become os.Args in the new process,\nso it normally starts with the program name.",
    "Desc": ":\nstarts a new process with the program, arguments and attributes specified by\nname, argv and attr. The argv slice will become os.Args in the new process,\nso it normally starts with the program name."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "exec_look_path(file string) =\u003e string/error",
    "Body": "exec_look_path(file string) =\u003e string/errorFunctions: searches for an executable\nnamed file in the directories named by the PATH environment variable.",
    "Desc": ": searches for an executable\nnamed file in the directories named by the PATH environment variable."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Functions",
    "Code": "exec(name string, args...) =\u003e Command/error",
    "Body": "exec(name string, args...) =\u003e Command/errorFunctions: returns the Command to execute\nthe named program with the given arguments.",
    "Desc": ": returns the Command to execute\nthe named program with the given arguments."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "chdir() =\u003e true/error",
    "Body": "chdir() =\u003e true/error: changes the current working directory to the file,",
    "Desc": ": changes the current working directory to the file,"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "chown(uid int, gid int) =\u003e true/error",
    "Body": "chown(uid int, gid int) =\u003e true/error: changes the numeric uid and gid of\nthe named file.",
    "Desc": ": changes the numeric uid and gid of\nthe named file."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "close() =\u003e error",
    "Body": "close() =\u003e error: closes the File, rendering it unusable for I/O.",
    "Desc": ": closes the File, rendering it unusable for I/O."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "name() =\u003e string",
    "Body": "name() =\u003e string: returns the name of the file as presented to Open.",
    "Desc": ": returns the name of the file as presented to Open."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "readdirnames(n int) =\u003e [string]/error",
    "Body": "readdirnames(n int) =\u003e [string]/error: reads and returns a slice of names\nfrom the directory.",
    "Desc": ": reads and returns a slice of names\nfrom the directory."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "sync() =\u003e error",
    "Body": "sync() =\u003e error: commits the current contents of the file to stable storage.",
    "Desc": ": commits the current contents of the file to stable storage."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "write(bytes) =\u003e int/error",
    "Body": "write(bytes) =\u003e int/error: writes len(b) bytes to the File.",
    "Desc": ": writes len(b) bytes to the File."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "write_string(string) =\u003e int/error",
    "Body": "write_string(string) =\u003e int/error: is like 'write', but writes the contents\nof string s rather than a slice of bytes.",
    "Desc": ": is like 'write', but writes the contents\nof string s rather than a slice of bytes."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "read(bytes) =\u003e int/error",
    "Body": "read(bytes) =\u003e int/error: reads up to len(b) bytes from the File.",
    "Desc": ": reads up to len(b) bytes from the File."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "stat() =\u003e FileInfo/error",
    "Body": "stat() =\u003e FileInfo/error: returns a file info structure describing the file",
    "Desc": ": returns a file info structure describing the file"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "chmod(mode int) =\u003e error",
    "Body": "chmod(mode int) =\u003e error: changes the mode of the file to mode.",
    "Desc": ": changes the mode of the file to mode."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "seek(offset int, whence int) =\u003e int/error",
    "Body": "seek(offset int, whence int) =\u003e int/error: sets the offset for the next\nRead or Write on file to offset, interpreted according to whence: 0 means\nrelative to the origin of the file, 1 means relative to the current offset,\nand 2 means relative to the end.",
    "Desc": ": sets the offset for the next\nRead or Write on file to offset, interpreted according to whence: 0 means\nrelative to the origin of the file, 1 means relative to the current offset,\nand 2 means relative to the end."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "kill() =\u003e error",
    "Body": "kill() =\u003e error: causes the Process to exit immediately.",
    "Desc": ": causes the Process to exit immediately."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "release() =\u003e error",
    "Body": "release() =\u003e error: releases any resources associated with the process,\nrendering it unusable in the future.",
    "Desc": ": releases any resources associated with the process,\nrendering it unusable in the future."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "signal(signal int) =\u003e error",
    "Body": "signal(signal int) =\u003e error: sends a signal to the Process.",
    "Desc": ": sends a signal to the Process."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "wait() =\u003e ProcessState/error",
    "Body": "wait() =\u003e ProcessState/error: waits for the Process to exit, and then\nreturns a ProcessState describing its status and an error, if any.",
    "Desc": ": waits for the Process to exit, and then\nreturns a ProcessState describing its status and an error, if any."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "exited() =\u003e bool",
    "Body": "exited() =\u003e bool: reports whether the program has exited.",
    "Desc": ": reports whether the program has exited."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "pid() =\u003e int",
    "Body": "pid() =\u003e int: returns the process id of the exited process.",
    "Desc": ": returns the process id of the exited process."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "string() =\u003e string",
    "Body": "string() =\u003e string: returns a string representation of the process.",
    "Desc": ": returns a string representation of the process."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "",
    "Code": "success() =\u003e bool",
    "Body": "success() =\u003e bool: reports whether the program exited successfully, such as\nwith exit status 0 on Unix.",
    "Desc": ": reports whether the program exited successfully, such as\nwith exit status 0 on Unix."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "FileInfo",
    "Code": "name",
    "Body": "nameFileInfo: name of the file the info describes",
    "Desc": ": name of the file the info describes"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "FileInfo",
    "Code": "mtime",
    "Body": "mtimeFileInfo: time the file was last modified",
    "Desc": ": time the file was last modified"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "FileInfo",
    "Code": "size",
    "Body": "sizeFileInfo: file size in bytes",
    "Desc": ": file size in bytes"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "FileInfo",
    "Code": "mode",
    "Body": "modeFileInfo: file permissions as in int, comparable to octal permissions",
    "Desc": ": file permissions as in int, comparable to octal permissions"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "FileInfo",
    "Code": "directory",
    "Body": "directoryFileInfo: boolean indicating if the file is a directory",
    "Desc": ": boolean indicating if the file is a directory"
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "combined_output() =\u003e bytes/error",
    "Body": "combined_output() =\u003e bytes/errorCommand: runs the command and returns its combined\nstandard output and standard error.",
    "Desc": ": runs the command and returns its combined\nstandard output and standard error."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "output() =\u003e bytes/error",
    "Body": "output() =\u003e bytes/errorCommand: runs the command and returns its standard output.",
    "Desc": ": runs the command and returns its standard output."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "run() =\u003e error",
    "Body": "run() =\u003e errorCommand: starts the specified command and waits for it to complete.",
    "Desc": ": starts the specified command and waits for it to complete."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "start() =\u003e error",
    "Body": "start() =\u003e errorCommand: starts the specified command but does not wait for it to\ncomplete.",
    "Desc": ": starts the specified command but does not wait for it to\ncomplete."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "wait() =\u003e error",
    "Body": "wait() =\u003e errorCommand: waits for the command to exit and waits for any copying to\nstdin or copying from stdout or stderr to complete.",
    "Desc": ": waits for the command to exit and waits for any copying to\nstdin or copying from stdout or stderr to complete."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "set_path(path string)",
    "Body": "set_path(path string)Command: sets the path of the command to run.",
    "Desc": ": sets the path of the command to run."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "set_dir(dir string)",
    "Body": "set_dir(dir string)Command: sets the working directory of the process.",
    "Desc": ": sets the working directory of the process."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "set_env(env [string])",
    "Body": "set_env(env [string])Command: sets the environment of the process.",
    "Desc": ": sets the environment of the process."
  },
  {
    "Type": 0,
    "Module": "os",
    "Object": "Command",
    "Code": "process() =\u003e Process",
    "Body": "process() =\u003e ProcessCommand: returns the underlying process, once started.",
    "Desc": ": returns the underlying process, once started."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "seed(seed int)",
    "Body": "seed(seed int)Functions: uses the provided seed value to initialize the default\nSource to a deterministic state.",
    "Desc": ": uses the provided seed value to initialize the default\nSource to a deterministic state."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "exp_float() =\u003e float",
    "Body": "exp_float() =\u003e floatFunctions:  returns an exponentially distributed float64 in the\nrange (0, +math.MaxFloat64] with an exponential distribution whose rate\nparameter (lambda) is 1 and whose mean is 1/lambda (1) from the default\nSource.",
    "Desc": ":  returns an exponentially distributed float64 in the\nrange (0, +math.MaxFloat64] with an exponential distribution whose rate\nparameter (lambda) is 1 and whose mean is 1/lambda (1) from the default\nSource."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "float() =\u003e float",
    "Body": "float() =\u003e floatFunctions: returns, as a float64, a pseudo-random number in\n[0.0,1.0) from the default Source.",
    "Desc": ": returns, as a float64, a pseudo-random number in\n[0.0,1.0) from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "int() =\u003e int",
    "Body": "int() =\u003e intFunctions: returns a non-negative pseudo-random 63-bit integer as an\nint64 from the default Source.",
    "Desc": ": returns a non-negative pseudo-random 63-bit integer as an\nint64 from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "intn(n int) =\u003e int",
    "Body": "intn(n int) =\u003e intFunctions: returns, as an int64, a non-negative pseudo-random\nnumber in [0,n) from the default Source. It panics if n \u003c= 0.",
    "Desc": ": returns, as an int64, a non-negative pseudo-random\nnumber in [0,n) from the default Source. It panics if n \u003c= 0."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "norm_float) =\u003e float",
    "Body": "norm_float) =\u003e floatFunctions: returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution\n(mean = 0, stddev = 1) from the default Source.",
    "Desc": ": returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution\n(mean = 0, stddev = 1) from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "perm(n int) =\u003e [int]",
    "Body": "perm(n int) =\u003e [int]Functions: returns, as a slice of n ints, a pseudo-random\npermutation of the integers [0,n) from the default Source.",
    "Desc": ": returns, as a slice of n ints, a pseudo-random\npermutation of the integers [0,n) from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "read(p bytes) =\u003e int/error",
    "Body": "read(p bytes) =\u003e int/errorFunctions: generates len(p) random bytes from the default\nSource and writes them into p. It always returns len(p) and a nil error.",
    "Desc": ": generates len(p) random bytes from the default\nSource and writes them into p. It always returns len(p) and a nil error."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Functions",
    "Code": "rand(src_seed int) =\u003e Rand",
    "Body": "rand(src_seed int) =\u003e RandFunctions: returns a new Rand that uses random values from\nsrc to generate other random values.",
    "Desc": ": returns a new Rand that uses random values from\nsrc to generate other random values."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "seed(seed int)",
    "Body": "seed(seed int)Rand: uses the provided seed value to initialize the default\nSource to a deterministic state.",
    "Desc": ": uses the provided seed value to initialize the default\nSource to a deterministic state."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "exp_float() =\u003e float",
    "Body": "exp_float() =\u003e floatRand:  returns an exponentially distributed float64 in the\nrange (0, +math.MaxFloat64] with an exponential distribution whose rate\nparameter (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.",
    "Desc": ":  returns an exponentially distributed float64 in the\nrange (0, +math.MaxFloat64] with an exponential distribution whose rate\nparameter (lambda) is 1 and whose mean is 1/lambda (1) from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "float() =\u003e float",
    "Body": "float() =\u003e floatRand: returns, as a float64, a pseudo-random number in\n[0.0,1.0) from the default Source.",
    "Desc": ": returns, as a float64, a pseudo-random number in\n[0.0,1.0) from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "int() =\u003e int",
    "Body": "int() =\u003e intRand: returns a non-negative pseudo-random 63-bit integer as an\nint64 from the default Source.",
    "Desc": ": returns a non-negative pseudo-random 63-bit integer as an\nint64 from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "intn(n int) =\u003e int",
    "Body": "intn(n int) =\u003e intRand: returns, as an int64, a non-negative pseudo-random\nnumber in [0,n) from the default Source. It panics if n \u003c= 0.",
    "Desc": ": returns, as an int64, a non-negative pseudo-random\nnumber in [0,n) from the default Source. It panics if n \u003c= 0."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "norm_float) =\u003e float",
    "Body": "norm_float) =\u003e floatRand: returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution\n(mean = 0, stddev = 1) from the default Source.",
    "Desc": ": returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution\n(mean = 0, stddev = 1) from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "perm(n int) =\u003e [int]",
    "Body": "perm(n int) =\u003e [int]Rand: returns, as a slice of n ints, a pseudo-random\npermutation of the integers [0,n) from the default Source.",
    "Desc": ": returns, as a slice of n ints, a pseudo-random\npermutation of the integers [0,n) from the default Source."
  },
  {
    "Type": 0,
    "Module": "rand",
    "Object": "Rand",
    "Code": "read(p bytes) =\u003e int/error",
    "Body": "read(p bytes) =\u003e int/errorRand: generates len(p) random bytes from the default\nSource and writes them into p. It always returns len(p) and a nil error.",
    "Desc": ": generates len(p) random bytes from the default\nSource and writes them into p. It always returns len(p) and a nil error."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "re_match(pattern string, text string) =\u003e bool/error",
    "Body": "re_match(pattern string, text string) =\u003e bool/errorFunctions: reports whether the\nstring s contains any match of the regular expression pattern.",
    "Desc": ": reports whether the\nstring s contains any match of the regular expression pattern."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "re_find(pattern string, text string, count int) =\u003e [[{text: string, begin: int, end: int}]]/undefined",
    "Body": "re_find(pattern string, text string, count int) =\u003e [[{text: string, begin: int, end: int}]]/undefinedFunctions:\nreturns an array holding all matches, each of which is an array of map object\nthat contains matching text, begin and end (exclusive) index.",
    "Desc": ":\nreturns an array holding all matches, each of which is an array of map object\nthat contains matching text, begin and end (exclusive) index."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "re_replace(pattern string, text string, repl string) =\u003e string/error",
    "Body": "re_replace(pattern string, text string, repl string) =\u003e string/errorFunctions:\nreturns a copy of src, replacing matches of the pattern with the replacement\nstring repl.",
    "Desc": ":\nreturns a copy of src, replacing matches of the pattern with the replacement\nstring repl."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "re_split(pattern string, text string, count int) =\u003e [string]/error",
    "Body": "re_split(pattern string, text string, count int) =\u003e [string]/errorFunctions: slices\ns into substrings separated by the expression and returns a slice of the\nsubstrings between those expression matches.",
    "Desc": ": slices\ns into substrings separated by the expression and returns a slice of the\nsubstrings between those expression matches."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "re_compile(pattern string) =\u003e Regexp/error",
    "Body": "re_compile(pattern string) =\u003e Regexp/errorFunctions: parses a regular expression and\nreturns, if successful, a Regexp object that can be used to match against\ntext.",
    "Desc": ": parses a regular expression and\nreturns, if successful, a Regexp object that can be used to match against\ntext."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "compare(a string, b string) =\u003e int",
    "Body": "compare(a string, b string) =\u003e intFunctions: returns an integer comparing two\nstrings lexicographically. The result will be 0 if a==b, -1 if a \u003c b, and +1\nif a \u003e b.",
    "Desc": ": returns an integer comparing two\nstrings lexicographically. The result will be 0 if a==b, -1 if a \u003c b, and +1\nif a \u003e b."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "contains(s string, substr string) =\u003e bool",
    "Body": "contains(s string, substr string) =\u003e boolFunctions: reports whether substr is within\ns.",
    "Desc": ": reports whether substr is within\ns."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "contains_any(s string, chars string) =\u003e bool",
    "Body": "contains_any(s string, chars string) =\u003e boolFunctions: reports whether any Unicode\ncode points in chars are within s.",
    "Desc": ": reports whether any Unicode\ncode points in chars are within s."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "count(s string, substr string) =\u003e int",
    "Body": "count(s string, substr string) =\u003e intFunctions: counts the number of non-overlapping\ninstances of substr in s.",
    "Desc": ": counts the number of non-overlapping\ninstances of substr in s."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "equal_fold(s string, t string) =\u003e bool",
    "Body": "equal_fold(s string, t string) =\u003e boolFunctions: reports whether s and t,\ninterpreted as UTF-8 strings,",
    "Desc": ": reports whether s and t,\ninterpreted as UTF-8 strings,"
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "fields(s string) =\u003e [string]",
    "Body": "fields(s string) =\u003e [string]Functions: splits the string s around each instance of\none or more consecutive white space characters, as defined by unicode.IsSpace,\nreturning a slice of substrings of s or an empty slice if s contains only\nwhite space.",
    "Desc": ": splits the string s around each instance of\none or more consecutive white space characters, as defined by unicode.IsSpace,\nreturning a slice of substrings of s or an empty slice if s contains only\nwhite space."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "has_prefix(s string, prefix string) =\u003e bool",
    "Body": "has_prefix(s string, prefix string) =\u003e boolFunctions: tests whether the string s\nbegins with prefix.",
    "Desc": ": tests whether the string s\nbegins with prefix."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "has_suffix(s string, suffix string) =\u003e bool",
    "Body": "has_suffix(s string, suffix string) =\u003e boolFunctions: tests whether the string s\nends with suffix.",
    "Desc": ": tests whether the string s\nends with suffix."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "index(s string, substr string) =\u003e int",
    "Body": "index(s string, substr string) =\u003e intFunctions: returns the index of the first\ninstance of substr in s, or -1 if substr is not present in s.",
    "Desc": ": returns the index of the first\ninstance of substr in s, or -1 if substr is not present in s."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "index_any(s string, chars string) =\u003e int",
    "Body": "index_any(s string, chars string) =\u003e intFunctions: returns the index of the first\ninstance of any Unicode code point from chars in s, or -1 if no Unicode code\npoint from chars is present in s.",
    "Desc": ": returns the index of the first\ninstance of any Unicode code point from chars in s, or -1 if no Unicode code\npoint from chars is present in s."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "join(arr string, sep string) =\u003e string",
    "Body": "join(arr string, sep string) =\u003e stringFunctions: concatenates the elements of a to\ncreate a single string. The separator string sep is placed between elements\nin the resulting string.",
    "Desc": ": concatenates the elements of a to\ncreate a single string. The separator string sep is placed between elements\nin the resulting string."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "last_index(s string, substr string) =\u003e int",
    "Body": "last_index(s string, substr string) =\u003e intFunctions: returns the index of the last\ninstance of substr in s, or -1 if substr is not present in s.",
    "Desc": ": returns the index of the last\ninstance of substr in s, or -1 if substr is not present in s."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "last_index_any(s string, chars string) =\u003e int",
    "Body": "last_index_any(s string, chars string) =\u003e intFunctions: returns the index of the\nlast instance of any Unicode code point from chars in s, or -1 if no Unicode\ncode point from chars is present in s.",
    "Desc": ": returns the index of the\nlast instance of any Unicode code point from chars in s, or -1 if no Unicode\ncode point from chars is present in s."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "repeat(s string, count int) =\u003e string",
    "Body": "repeat(s string, count int) =\u003e stringFunctions: returns a new string consisting of\ncount copies of the string s.",
    "Desc": ": returns a new string consisting of\ncount copies of the string s."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "replace(s string, old string, new string, n int) =\u003e string",
    "Body": "replace(s string, old string, new string, n int) =\u003e stringFunctions: returns a copy\nof the string s with the first n non-overlapping instances of old replaced by\nnew.",
    "Desc": ": returns a copy\nof the string s with the first n non-overlapping instances of old replaced by\nnew."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "substr(s string, lower int, upper int) =\u003e string =\u003e string",
    "Body": "substr(s string, lower int, upper int) =\u003e string =\u003e stringFunctions: returns a\nsubstring of the string s specified by the lower and upper parameters.",
    "Desc": ": returns a\nsubstring of the string s specified by the lower and upper parameters."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "split(s string, sep string) =\u003e [string]",
    "Body": "split(s string, sep string) =\u003e [string]Functions: slices s into all substrings\nseparated by sep and returns a slice of the substrings between those\nseparators.",
    "Desc": ": slices s into all substrings\nseparated by sep and returns a slice of the substrings between those\nseparators."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "split_after(s string, sep string) =\u003e [string]",
    "Body": "split_after(s string, sep string) =\u003e [string]Functions: slices s into all substrings\nafter each instance of sep and returns a slice of those substrings.",
    "Desc": ": slices s into all substrings\nafter each instance of sep and returns a slice of those substrings."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "split_after_n(s string, sep string, n int) =\u003e [string]",
    "Body": "split_after_n(s string, sep string, n int) =\u003e [string]Functions: slices s into\nsubstrings after each instance of sep and returns a slice of those substrings.",
    "Desc": ": slices s into\nsubstrings after each instance of sep and returns a slice of those substrings."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "split_n(s string, sep string, n int) =\u003e [string]",
    "Body": "split_n(s string, sep string, n int) =\u003e [string]Functions: slices s into substrings\nseparated by sep and returns a slice of the substrings between those\nseparators.",
    "Desc": ": slices s into substrings\nseparated by sep and returns a slice of the substrings between those\nseparators."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "title(s string) =\u003e string",
    "Body": "title(s string) =\u003e stringFunctions: returns a copy of the string s with all Unicode\nletters that begin words mapped to their title case.",
    "Desc": ": returns a copy of the string s with all Unicode\nletters that begin words mapped to their title case."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "to_lower(s string) =\u003e string",
    "Body": "to_lower(s string) =\u003e stringFunctions: returns a copy of the string s with all\nUnicode letters mapped to their lower case.",
    "Desc": ": returns a copy of the string s with all\nUnicode letters mapped to their lower case."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "to_title(s string) =\u003e string",
    "Body": "to_title(s string) =\u003e stringFunctions: returns a copy of the string s with all\nUnicode letters mapped to their title case.",
    "Desc": ": returns a copy of the string s with all\nUnicode letters mapped to their title case."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "to_upper(s string) =\u003e string",
    "Body": "to_upper(s string) =\u003e stringFunctions: returns a copy of the string s with all\nUnicode letters mapped to their upper case.",
    "Desc": ": returns a copy of the string s with all\nUnicode letters mapped to their upper case."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "pad_left(s string, pad_len int, pad_with string) =\u003e string",
    "Body": "pad_left(s string, pad_len int, pad_with string) =\u003e stringFunctions: returns a copy\nof the string s padded on the left with the contents of the string pad_with\nto length pad_len. If pad_with is not specified, white space is used as the\ndefault padding.",
    "Desc": ": returns a copy\nof the string s padded on the left with the contents of the string pad_with\nto length pad_len. If pad_with is not specified, white space is used as the\ndefault padding."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "pad_right(s string, pad_len int, pad_with string) =\u003e string",
    "Body": "pad_right(s string, pad_len int, pad_with string) =\u003e stringFunctions: returns a\ncopy of the string s padded on the right with the contents of the string\npad_with to length pad_len. If pad_with is not specified, white space is\nused as the default padding.",
    "Desc": ": returns a\ncopy of the string s padded on the right with the contents of the string\npad_with to length pad_len. If pad_with is not specified, white space is\nused as the default padding."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "trim(s string, cutset string) =\u003e string",
    "Body": "trim(s string, cutset string) =\u003e stringFunctions: returns a slice of the string s\nwith all leading and trailing Unicode code points contained in cutset removed.",
    "Desc": ": returns a slice of the string s\nwith all leading and trailing Unicode code points contained in cutset removed."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "trim_left(s string, cutset string) =\u003e string",
    "Body": "trim_left(s string, cutset string) =\u003e stringFunctions: returns a slice of the string\ns with all leading Unicode code points contained in cutset removed.",
    "Desc": ": returns a slice of the string\ns with all leading Unicode code points contained in cutset removed."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "trim_prefix(s string, prefix string) =\u003e string",
    "Body": "trim_prefix(s string, prefix string) =\u003e stringFunctions: returns s without the\nprovided leading prefix string.",
    "Desc": ": returns s without the\nprovided leading prefix string."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "trim_right(s string, cutset string) =\u003e string",
    "Body": "trim_right(s string, cutset string) =\u003e stringFunctions: returns a slice of the\nstring s, with all trailing Unicode code points contained in cutset removed.",
    "Desc": ": returns a slice of the\nstring s, with all trailing Unicode code points contained in cutset removed."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "trim_space(s string) =\u003e string",
    "Body": "trim_space(s string) =\u003e stringFunctions: returns a slice of the string s, with all\nleading and trailing white space removed, as defined by Unicode.",
    "Desc": ": returns a slice of the string s, with all\nleading and trailing white space removed, as defined by Unicode."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "trim_suffix(s string, suffix string) =\u003e string",
    "Body": "trim_suffix(s string, suffix string) =\u003e stringFunctions: returns s without the\nprovided trailing suffix string.",
    "Desc": ": returns s without the\nprovided trailing suffix string."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "atoi(str string) =\u003e int/error",
    "Body": "atoi(str string) =\u003e int/errorFunctions: returns the result of ParseInt(s, 10, 0)\nconverted to type int.",
    "Desc": ": returns the result of ParseInt(s, 10, 0)\nconverted to type int."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "format_bool(b bool) =\u003e string",
    "Body": "format_bool(b bool) =\u003e stringFunctions: returns \"true\" or \"false\" according to the\nvalue of b.",
    "Desc": ": returns \"true\" or \"false\" according to the\nvalue of b."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "format_float(f float, fmt string, prec int, bits int) =\u003e string",
    "Body": "format_float(f float, fmt string, prec int, bits int) =\u003e stringFunctions: converts\nthe floating-point number f to a string, according to the format fmt and\nprecision prec.",
    "Desc": ": converts\nthe floating-point number f to a string, according to the format fmt and\nprecision prec."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "format_int(i int, base int) =\u003e string",
    "Body": "format_int(i int, base int) =\u003e stringFunctions: returns the string representation of\ni in the given base, for 2 \u003c= base \u003c= 36. The result uses the lower-case\nletters 'a' to 'z' for digit values \u003e= 10.",
    "Desc": ": returns the string representation of\ni in the given base, for 2 \u003c= base \u003c= 36. The result uses the lower-case\nletters 'a' to 'z' for digit values \u003e= 10."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "itoa(i int) =\u003e string",
    "Body": "itoa(i int) =\u003e stringFunctions: is shorthand for format_int(i, 10).",
    "Desc": ": is shorthand for format_int(i, 10)."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "parse_bool(s string) =\u003e bool/error",
    "Body": "parse_bool(s string) =\u003e bool/errorFunctions: returns the boolean value represented\nby the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false,\nFalse. Any other value returns an error.",
    "Desc": ": returns the boolean value represented\nby the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false,\nFalse. Any other value returns an error."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "parse_float(s string, bits int) =\u003e float/error",
    "Body": "parse_float(s string, bits int) =\u003e float/errorFunctions: converts the string s to a\nfloating-point number with the precision specified by bitSize: 32 for float32,\nor 64 for float64. When bitSize=32, the result still has type float64, but it\nwill be convertible to float32 without changing its value.",
    "Desc": ": converts the string s to a\nfloating-point number with the precision specified by bitSize: 32 for float32,\nor 64 for float64. When bitSize=32, the result still has type float64, but it\nwill be convertible to float32 without changing its value."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "parse_int(s string, base int, bits int) =\u003e int/error",
    "Body": "parse_int(s string, base int, bits int) =\u003e int/errorFunctions: interprets a string s\nin the given base (0, 2 to 36) and bit size (0 to 64) and returns the\ncorresponding value i.",
    "Desc": ": interprets a string s\nin the given base (0, 2 to 36) and bit size (0 to 64) and returns the\ncorresponding value i."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "quote(s string) =\u003e string",
    "Body": "quote(s string) =\u003e stringFunctions: returns a double-quoted Go string literal\nrepresenting s. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for control characters and non-printable characters as defined by\nIsPrint.",
    "Desc": ": returns a double-quoted Go string literal\nrepresenting s. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for control characters and non-printable characters as defined by\nIsPrint."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Functions",
    "Code": "unquote(s string) =\u003e string/error",
    "Body": "unquote(s string) =\u003e string/errorFunctions: interprets s as a single-quoted,\ndouble-quoted, or backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go character literal;\nUnquote returns the corresponding one-character string.)",
    "Desc": ": interprets s as a single-quoted,\ndouble-quoted, or backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go character literal;\nUnquote returns the corresponding one-character string.)"
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Regexp",
    "Code": "match(text string) =\u003e bool",
    "Body": "match(text string) =\u003e boolRegexp: reports whether the string s contains any match\nof the regular expression pattern.",
    "Desc": ": reports whether the string s contains any match\nof the regular expression pattern."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Regexp",
    "Code": "find(text string, count int) =\u003e [[{text: string, begin: int, end: int}]]/undefined",
    "Body": "find(text string, count int) =\u003e [[{text: string, begin: int, end: int}]]/undefinedRegexp:\nreturns an array holding all matches, each of which is an array of map object\nthat contains matching text, begin and end (exclusive) index.",
    "Desc": ":\nreturns an array holding all matches, each of which is an array of map object\nthat contains matching text, begin and end (exclusive) index."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Regexp",
    "Code": "replace(src string, repl string) =\u003e string",
    "Body": "replace(src string, repl string) =\u003e stringRegexp: returns a copy of src,\nreplacing matches of the pattern with the replacement string repl.",
    "Desc": ": returns a copy of src,\nreplacing matches of the pattern with the replacement string repl."
  },
  {
    "Type": 0,
    "Module": "text",
    "Object": "Regexp",
    "Code": "split(text string, count int) =\u003e [string]",
    "Body": "split(text string, count int) =\u003e [string]Regexp: slices s into substrings\nseparated by the expression and returns a slice of the substrings between\nthose expression matches.",
    "Desc": ": slices s into substrings\nseparated by the expression and returns a slice of the substrings between\nthose expression matches."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_ansic",
    "Body": "format_ansicConstants: time format \"Mon Jan _2 15:04:05 2006\"",
    "Desc": ": time format \"Mon Jan _2 15:04:05 2006\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_unix_date",
    "Body": "format_unix_dateConstants: time format \"Mon Jan _2 15:04:05 MST 2006\"",
    "Desc": ": time format \"Mon Jan _2 15:04:05 MST 2006\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_ruby_date",
    "Body": "format_ruby_dateConstants: time format \"Mon Jan 02 15:04:05 -0700 2006\"",
    "Desc": ": time format \"Mon Jan 02 15:04:05 -0700 2006\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_rfc822",
    "Body": "format_rfc822Constants: time format \"02 Jan 06 15:04 MST\"",
    "Desc": ": time format \"02 Jan 06 15:04 MST\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_rfc822z",
    "Body": "format_rfc822zConstants: time format \"02 Jan 06 15:04 -0700\"",
    "Desc": ": time format \"02 Jan 06 15:04 -0700\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_rfc850",
    "Body": "format_rfc850Constants: time format \"Monday, 02-Jan-06 15:04:05 MST\"",
    "Desc": ": time format \"Monday, 02-Jan-06 15:04:05 MST\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_rfc1123",
    "Body": "format_rfc1123Constants: time format \"Mon, 02 Jan 2006 15:04:05 MST\"",
    "Desc": ": time format \"Mon, 02 Jan 2006 15:04:05 MST\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_rfc1123z",
    "Body": "format_rfc1123zConstants: time format \"Mon, 02 Jan 2006 15:04:05 -0700\"",
    "Desc": ": time format \"Mon, 02 Jan 2006 15:04:05 -0700\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_rfc3339",
    "Body": "format_rfc3339Constants: time format \"2006-01-02T15:04:05Z07:00\"",
    "Desc": ": time format \"2006-01-02T15:04:05Z07:00\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_rfc3339_nano",
    "Body": "format_rfc3339_nanoConstants: time format \"2006-01-02T15:04:05.999999999Z07:00\"",
    "Desc": ": time format \"2006-01-02T15:04:05.999999999Z07:00\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_kitchen",
    "Body": "format_kitchenConstants: time format \"3:04PM\"",
    "Desc": ": time format \"3:04PM\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_stamp",
    "Body": "format_stampConstants: time format \"Jan _2 15:04:05\"",
    "Desc": ": time format \"Jan _2 15:04:05\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_stamp_milli",
    "Body": "format_stamp_milliConstants: time format \"Jan _2 15:04:05.000\"",
    "Desc": ": time format \"Jan _2 15:04:05.000\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_stamp_micro",
    "Body": "format_stamp_microConstants: time format \"Jan _2 15:04:05.000000\"",
    "Desc": ": time format \"Jan _2 15:04:05.000000\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "format_stamp_nano",
    "Body": "format_stamp_nanoConstants: time format \"Jan _2 15:04:05.000000000\"",
    "Desc": ": time format \"Jan _2 15:04:05.000000000\""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "nanosecond",
    "Body": "nanosecondConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "microsecond",
    "Body": "microsecondConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "millisecond",
    "Body": "millisecondConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "second",
    "Body": "secondConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "minute",
    "Body": "minuteConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "hour",
    "Body": "hourConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "january",
    "Body": "januaryConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "february",
    "Body": "februaryConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "march",
    "Body": "marchConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "april",
    "Body": "aprilConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "may",
    "Body": "mayConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "june",
    "Body": "juneConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "july",
    "Body": "julyConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "august",
    "Body": "augustConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "september",
    "Body": "septemberConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "october",
    "Body": "octoberConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "november",
    "Body": "novemberConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Constants",
    "Code": "december",
    "Body": "decemberConstants",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "sleep(duration int)",
    "Body": "sleep(duration int)Functions: pauses the current goroutine for at least the duration\nd. A negative or zero duration causes Sleep to return immediately.",
    "Desc": ": pauses the current goroutine for at least the duration\nd. A negative or zero duration causes Sleep to return immediately."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "parse_duration(s string) =\u003e int",
    "Body": "parse_duration(s string) =\u003e intFunctions: parses a duration string. A duration\nstring is a possibly signed sequence of decimal numbers, each with optional\nfraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time\nunits are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".",
    "Desc": ": parses a duration string. A duration\nstring is a possibly signed sequence of decimal numbers, each with optional\nfraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time\nunits are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\"."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "since(t time) =\u003e int",
    "Body": "since(t time) =\u003e intFunctions: returns the time elapsed since t.",
    "Desc": ": returns the time elapsed since t."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "until(t time) =\u003e int",
    "Body": "until(t time) =\u003e intFunctions: returns the duration until t.",
    "Desc": ": returns the duration until t."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "duration_hours(duration int) =\u003e float",
    "Body": "duration_hours(duration int) =\u003e floatFunctions: returns the duration as a floating\npoint number of hours.",
    "Desc": ": returns the duration as a floating\npoint number of hours."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "duration_minutes(duration int) =\u003e float",
    "Body": "duration_minutes(duration int) =\u003e floatFunctions: returns the duration as a floating\npoint number of minutes.",
    "Desc": ": returns the duration as a floating\npoint number of minutes."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "duration_nanoseconds(duration int) =\u003e int",
    "Body": "duration_nanoseconds(duration int) =\u003e intFunctions: returns the duration as an\ninteger of nanoseconds.",
    "Desc": ": returns the duration as an\ninteger of nanoseconds."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "duration_seconds(duration int) =\u003e float",
    "Body": "duration_seconds(duration int) =\u003e floatFunctions: returns the duration as a floating\npoint number of seconds.",
    "Desc": ": returns the duration as a floating\npoint number of seconds."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "duration_string(duration int) =\u003e string",
    "Body": "duration_string(duration int) =\u003e stringFunctions: returns a string representation of\nduration.",
    "Desc": ": returns a string representation of\nduration."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "month_string(month int) =\u003e string",
    "Body": "month_string(month int) =\u003e stringFunctions:  returns the English name of the month\n(\"January\", \"February\", ...).",
    "Desc": ":  returns the English name of the month\n(\"January\", \"February\", ...)."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "date(year int, month int, day int, hour int, min int, sec int, nsec int) =\u003e time",
    "Body": "date(year int, month int, day int, hour int, min int, sec int, nsec int) =\u003e timeFunctions:\nreturns the Time corresponding to \"yyyy-mm-dd hh:mm:ss + nsec nanoseconds\".\nCurrent location is used.",
    "Desc": ":\nreturns the Time corresponding to \"yyyy-mm-dd hh:mm:ss + nsec nanoseconds\".\nCurrent location is used."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "now() =\u003e time",
    "Body": "now() =\u003e timeFunctions: returns the current local time.",
    "Desc": ": returns the current local time."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "parse(format string, s string) =\u003e time",
    "Body": "parse(format string, s string) =\u003e timeFunctions: parses a formatted string and\nreturns the time value it represents. The layout defines the format by\nshowing how the reference time, defined to be \"Mon Jan 2 15:04:05 -0700 MST\n2006\" would be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the input\nstring.",
    "Desc": ": parses a formatted string and\nreturns the time value it represents. The layout defines the format by\nshowing how the reference time, defined to be \"Mon Jan 2 15:04:05 -0700 MST\n2006\" would be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the input\nstring."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "unix(sec int, nsec int) =\u003e time",
    "Body": "unix(sec int, nsec int) =\u003e timeFunctions: returns the local Time corresponding to\nthe given Unix time, sec seconds and nsec nanoseconds since January 1,\n1970 UTC.",
    "Desc": ": returns the local Time corresponding to\nthe given Unix time, sec seconds and nsec nanoseconds since January 1,\n1970 UTC."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "add(t time, duration int) =\u003e time",
    "Body": "add(t time, duration int) =\u003e timeFunctions: returns the time t+d.",
    "Desc": ": returns the time t+d."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "add_date(t time, years int, months int, days int) =\u003e time",
    "Body": "add_date(t time, years int, months int, days int) =\u003e timeFunctions: returns the time\ncorresponding to adding the given number of years, months, and days to t. For\nexample, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010.",
    "Desc": ": returns the time\ncorresponding to adding the given number of years, months, and days to t. For\nexample, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "sub(t time, u time) =\u003e int",
    "Body": "sub(t time, u time) =\u003e intFunctions: returns the duration t-u.",
    "Desc": ": returns the duration t-u."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "after(t time, u time) =\u003e bool",
    "Body": "after(t time, u time) =\u003e boolFunctions: reports whether the time instant t is after\nu.",
    "Desc": ": reports whether the time instant t is after\nu."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "before(t time, u time) =\u003e bool",
    "Body": "before(t time, u time) =\u003e boolFunctions: reports whether the time instant t is\nbefore u.",
    "Desc": ": reports whether the time instant t is\nbefore u."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_year(t time) =\u003e int",
    "Body": "time_year(t time) =\u003e intFunctions: returns the year in which t occurs.",
    "Desc": ": returns the year in which t occurs."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_month(t time) =\u003e int",
    "Body": "time_month(t time) =\u003e intFunctions: returns the month of the year specified by t.",
    "Desc": ": returns the month of the year specified by t."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_day(t time) =\u003e int",
    "Body": "time_day(t time) =\u003e intFunctions: returns the day of the month specified by t.",
    "Desc": ": returns the day of the month specified by t."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_weekday(t time) =\u003e int",
    "Body": "time_weekday(t time) =\u003e intFunctions: returns the day of the week specified by t.",
    "Desc": ": returns the day of the week specified by t."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_hour(t time) =\u003e int",
    "Body": "time_hour(t time) =\u003e intFunctions: returns the hour within the day specified by t,\nin the range [0, 23].",
    "Desc": ": returns the hour within the day specified by t,\nin the range [0, 23]."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_minute(t time) =\u003e int",
    "Body": "time_minute(t time) =\u003e intFunctions: returns the minute offset within the hour\nspecified by t, in the range [0, 59].",
    "Desc": ": returns the minute offset within the hour\nspecified by t, in the range [0, 59]."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_second(t time) =\u003e int",
    "Body": "time_second(t time) =\u003e intFunctions: returns the second offset within the minute\nspecified by t, in the range [0, 59].",
    "Desc": ": returns the second offset within the minute\nspecified by t, in the range [0, 59]."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_nanosecond(t time) =\u003e int",
    "Body": "time_nanosecond(t time) =\u003e intFunctions: returns the nanosecond offset within the\nsecond specified by t, in the range [0, 999999999].",
    "Desc": ": returns the nanosecond offset within the\nsecond specified by t, in the range [0, 999999999]."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_unix(t time) =\u003e int",
    "Body": "time_unix(t time) =\u003e intFunctions: returns t as a Unix time, the number of seconds\nelapsed since January 1, 1970 UTC. The result does not depend on the location\nassociated with t.",
    "Desc": ": returns t as a Unix time, the number of seconds\nelapsed since January 1, 1970 UTC. The result does not depend on the location\nassociated with t."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_unix_nano(t time) =\u003e int",
    "Body": "time_unix_nano(t time) =\u003e intFunctions: returns t as a Unix time, the number of\nnanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the\nUnix time in nanoseconds cannot be represented by an int64 (a date before the\nyear 1678 or after 2262). Note that this means the result of calling UnixNano\non the zero Time is undefined. The result does not depend on the location\nassociated with t.",
    "Desc": ": returns t as a Unix time, the number of\nnanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the\nUnix time in nanoseconds cannot be represented by an int64 (a date before the\nyear 1678 or after 2262). Note that this means the result of calling UnixNano\non the zero Time is undefined. The result does not depend on the location\nassociated with t."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_format(t time, format) =\u003e string",
    "Body": "time_format(t time, format) =\u003e stringFunctions: returns a textual representation of\nhe time value formatted according to layout, which defines the format by\nshowing how the reference time, defined to be \"Mon Jan 2 15:04:05 -0700 MST\n2006\" would be displayed if it were the value; it serves as an example of the\ndesired output. The same display rules will then be applied to the time value.",
    "Desc": ": returns a textual representation of\nhe time value formatted according to layout, which defines the format by\nshowing how the reference time, defined to be \"Mon Jan 2 15:04:05 -0700 MST\n2006\" would be displayed if it were the value; it serves as an example of the\ndesired output. The same display rules will then be applied to the time value."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_location(t time) =\u003e string",
    "Body": "time_location(t time) =\u003e stringFunctions: returns the time zone name associated with\nt.",
    "Desc": ": returns the time zone name associated with\nt."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "time_string(t time) =\u003e string",
    "Body": "time_string(t time) =\u003e stringFunctions: returns the time formatted using the format\nstring \"2006-01-02 15:04:05.999999999 -0700 MST\".",
    "Desc": ": returns the time formatted using the format\nstring \"2006-01-02 15:04:05.999999999 -0700 MST\"."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "is_zero(t time) =\u003e bool",
    "Body": "is_zero(t time) =\u003e boolFunctions: reports whether t represents the zero time\ninstant, January 1, year 1, 00:00:00 UTC.",
    "Desc": ": reports whether t represents the zero time\ninstant, January 1, year 1, 00:00:00 UTC."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "to_local(t time) =\u003e time",
    "Body": "to_local(t time) =\u003e timeFunctions: returns t with the location set to local time.",
    "Desc": ": returns t with the location set to local time."
  },
  {
    "Type": 0,
    "Module": "times",
    "Object": "Functions",
    "Code": "to_utc(t time) =\u003e time",
    "Body": "to_utc(t time) =\u003e timeFunctions: returns t with the location set to UTC.",
    "Desc": ": returns t with the location set to UTC."
  },
  {
    "Type": 0,
    "Module": "tengo-cli",
    "Object": "",
    "Code": "tengo",
    "Body": "tengo CLI tool.",
    "Desc": " CLI tool."
  },
  {
    "Type": 0,
    "Module": "tengo-cli",
    "Object": "",
    "Code": "tengo",
    "Body": "tengo tool, run:",
    "Desc": " tool, run:"
  },
  {
    "Type": 0,
    "Module": "tengo-cli",
    "Object": "",
    "Code": "tengo",
    "Body": "tengo tool with\nyour Tengo source file (*.tengo).",
    "Desc": " tool with\nyour Tengo source file (*.tengo)."
  },
  {
    "Type": 0,
    "Module": "tengo-cli",
    "Object": "",
    "Code": "*.tengo",
    "Body": "*.tengo).",
    "Desc": ")."
  },
  {
    "Type": 0,
    "Module": "tengo-cli",
    "Object": "",
    "Code": ".tengo",
    "Body": ".tengo extension.",
    "Desc": " extension."
  },
  {
    "Type": 0,
    "Module": "tengo-cli",
    "Object": "",
    "Code": "-resolve",
    "Body": "-resolve flag. Flag enables to import a module relative to\nimporting file. This behavior will be default at version 3.",
    "Desc": " flag. Flag enables to import a module relative to\nimporting file. This behavior will be default at version 3."
  },
  {
    "Type": 0,
    "Module": "tengo-cli",
    "Object": "",
    "Code": "tengo",
    "Body": "tengo with no arguments.",
    "Desc": " with no arguments."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "int64",
    "Body": "int64",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "float64",
    "Body": "float64",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "bool",
    "Body": "bool",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "rune",
    "Body": "rune",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "string",
    "Body": "string",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "[]byte",
    "Body": "[]byte",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "time.Time",
    "Body": "time.Time",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "[]interface{}",
    "Body": "[]interface{}",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "map[string]interface{}",
    "Body": "map[string]interface{}",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "error",
    "Body": "error expression, and, it must have an underlying\nvalue. The underlying value of an error value can be access using .value\nselector.",
    "Desc": " expression, and, it must have an underlying\nvalue. The underlying value of an error value can be access using .value\nselector."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": ".value",
    "Body": ".value\nselector.",
    "Desc": "\nselector."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "immutable",
    "Body": "immutable expression.",
    "Desc": " expression."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "copy",
    "Body": "copy builtin function) an immutable value, it\nwill return a \"mutable\" copy. Also, immutability is not applied to the\nindividual elements of the array or map value, unless they are explicitly made\nimmutable.",
    "Desc": " builtin function) an immutable value, it\nwill return a \"mutable\" copy. Also, immutability is not applied to the\nindividual elements of the array or map value, unless they are explicitly made\nimmutable."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "undefined",
    "Body": "undefined value.",
    "Desc": " value."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "undefined",
    "Body": "undefined if the\nkey or index does not exist.",
    "Desc": " if the\nkey or index does not exist."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "undefined",
    "Body": "undefined if conversion fails.",
    "Desc": " if conversion fails."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "[]",
    "Body": "[].",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "[]",
    "Body": "[] or\nselector '.' operators.",
    "Desc": " or\nselector '.' operators."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "...",
    "Body": "... to pass array-type value as its last parameter:",
    "Desc": " to pass array-type value as its last parameter:"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": ":=",
    "Body": ":= and =.",
    "Desc": " and =."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "=",
    "Body": "=.",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": ":=",
    "Body": ":= operator defines a new variable in the scope and assigns a value.",
    "Desc": " operator defines a new variable in the scope and assigns a value."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "=",
    "Body": "= operator assigns a new value to an existing variable in the scope.",
    "Desc": " operator assigns a new value to an existing variable in the scope."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "+",
    "Body": "+",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "0 + x",
    "Body": "0 + x",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "-",
    "Body": "-",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "0 - x",
    "Body": "0 - x",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "!",
    "Body": "!",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "^",
    "Body": "^",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "==",
    "Body": "==",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "!=",
    "Body": "!=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026\u0026",
    "Body": "\u0026\u0026",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\\|\\|",
    "Body": "\\|\\|",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "+",
    "Body": "+",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "-",
    "Body": "-",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "*",
    "Body": "*",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "/",
    "Body": "/",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026",
    "Body": "\u0026",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\\|",
    "Body": "\\|",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "^",
    "Body": "^",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026^",
    "Body": "\u0026^",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003c\u003c",
    "Body": "\u003c\u003c",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003e\u003e",
    "Body": "\u003e\u003e",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003c",
    "Body": "\u003c",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003c=",
    "Body": "\u003c=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003e",
    "Body": "\u003e",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003e=",
    "Body": "\u003e=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(condition expression) ? (true expression) : (false expression)",
    "Body": "(condition expression) ? (true expression) : (false expression).",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "+=",
    "Body": "+=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) + (rhs)",
    "Body": "(lhs) = (lhs) + (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "-=",
    "Body": "-=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) - (rhs)",
    "Body": "(lhs) = (lhs) - (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "*=",
    "Body": "*=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) * (rhs)",
    "Body": "(lhs) = (lhs) * (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "/=",
    "Body": "/=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) / (rhs)",
    "Body": "(lhs) = (lhs) / (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "%=",
    "Body": "%=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) % (rhs)",
    "Body": "(lhs) = (lhs) % (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026=",
    "Body": "\u0026=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) \u0026 (rhs)",
    "Body": "(lhs) = (lhs) \u0026 (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\\|=",
    "Body": "\\|=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) \\| (rhs)",
    "Body": "(lhs) = (lhs) \\| (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026^=",
    "Body": "\u0026^=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) \u0026^ (rhs)",
    "Body": "(lhs) = (lhs) \u0026^ (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "^=",
    "Body": "^=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) ^ (rhs)",
    "Body": "(lhs) = (lhs) ^ (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003c\u003c=",
    "Body": "\u003c\u003c=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) \u003c\u003c (rhs)",
    "Body": "(lhs) = (lhs) \u003c\u003c (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003e\u003e=",
    "Body": "\u003e\u003e=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) \u003e\u003e (rhs)",
    "Body": "(lhs) = (lhs) \u003e\u003e (rhs)",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "++",
    "Body": "++",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) + 1",
    "Body": "(lhs) = (lhs) + 1",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "--",
    "Body": "--",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "(lhs) = (lhs) - 1",
    "Body": "(lhs) = (lhs) - 1",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026\u0026",
    "Body": "\u0026\u0026 (logical AND), and finally || (logical OR):",
    "Desc": " (logical AND), and finally || (logical OR):"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "||",
    "Body": "|| (logical OR):",
    "Desc": " (logical OR):"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "*",
    "Body": "*  /  %  \u003c\u003c  \u003e\u003e  \u0026  \u0026^",
    "Desc": "  /  %  \u003c\u003c  \u003e\u003e  \u0026  \u0026^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "/",
    "Body": "/  %  \u003c\u003c  \u003e\u003e  \u0026  \u0026^",
    "Desc": "  %  \u003c\u003c  \u003e\u003e  \u0026  \u0026^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "%",
    "Body": "%  \u003c\u003c  \u003e\u003e  \u0026  \u0026^",
    "Desc": "  \u003c\u003c  \u003e\u003e  \u0026  \u0026^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003c\u003c",
    "Body": "\u003c\u003c  \u003e\u003e  \u0026  \u0026^",
    "Desc": "  \u003e\u003e  \u0026  \u0026^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003e\u003e",
    "Body": "\u003e\u003e  \u0026  \u0026^",
    "Desc": "  \u0026  \u0026^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026",
    "Body": "\u0026  \u0026^",
    "Desc": "  \u0026^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026^",
    "Body": "\u0026^",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "+",
    "Body": "+  -  \\|  ^",
    "Desc": "  -  \\|  ^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "-",
    "Body": "-  \\|  ^",
    "Desc": "  \\|  ^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\\|",
    "Body": "\\|  ^",
    "Desc": "  ^"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "^",
    "Body": "^",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "==",
    "Body": "==  !=  \u003c  \u003c=  \u003e  \u003e=",
    "Desc": "  !=  \u003c  \u003c=  \u003e  \u003e="
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "!=",
    "Body": "!=  \u003c  \u003c=  \u003e  \u003e=",
    "Desc": "  \u003c  \u003c=  \u003e  \u003e="
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003c",
    "Body": "\u003c  \u003c=  \u003e  \u003e=",
    "Desc": "  \u003c=  \u003e  \u003e="
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003c=",
    "Body": "\u003c=  \u003e  \u003e=",
    "Desc": "  \u003e  \u003e="
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003e",
    "Body": "\u003e  \u003e=",
    "Desc": "  \u003e="
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u003e=",
    "Body": "\u003e=",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\u0026\u0026",
    "Body": "\u0026\u0026",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "\\|\\|",
    "Body": "\\|\\|",
    "Desc": ""
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "++",
    "Body": "++ and -- operators form statements, not expressions, they fall\noutside the operator hierarchy.",
    "Desc": " and -- operators form statements, not expressions, they fall\noutside the operator hierarchy."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "--",
    "Body": "-- operators form statements, not expressions, they fall\noutside the operator hierarchy.",
    "Desc": " operators form statements, not expressions, they fall\noutside the operator hierarchy."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": ".",
    "Body": ".) and indexer ([]) operators to read or write\nelements of composite types (array, map, string, bytes).",
    "Desc": ") and indexer ([]) operators to read or write\nelements of composite types (array, map, string, bytes)."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "[]",
    "Body": "[]) operators to read or write\nelements of composite types (array, map, string, bytes).",
    "Desc": ") operators to read or write\nelements of composite types (array, map, string, bytes)."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "[:]",
    "Body": "[:] for sequence value types such as\narray, string, bytes.",
    "Desc": " for sequence value types such as\narray, string, bytes."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "for range",
    "Body": "for range statement.\n\"For-In\" statement can iterate any iterable value types (array, map, bytes,\nstring, undefined).",
    "Desc": " statement.\n\"For-In\" statement can iterate any iterable value types (array, map, bytes,\nstring, undefined)."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "import",
    "Body": "import expression.",
    "Desc": " expression."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "sum.tengo",
    "Body": "sum.tengo file:",
    "Desc": " file:"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "import",
    "Body": "import solves the missing extension name of a module file as\n\".tengo\"[^note].\nThus, sum := import(\"./sum\") is equivalent to sum := import(\"./sum.tengo\").",
    "Desc": " solves the missing extension name of a module file as\n\".tengo\"[^note].\nThus, sum := import(\"./sum\") is equivalent to sum := import(\"./sum.tengo\")."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": ".tengo",
    "Body": ".tengo\"[^note].\nThus, sum := import(\"./sum\") is equivalent to sum := import(\"./sum.tengo\").",
    "Desc": "\"[^note].\nThus, sum := import(\"./sum\") is equivalent to sum := import(\"./sum.tengo\")."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "sum := import(\"./sum\")",
    "Body": "sum := import(\"./sum\") is equivalent to sum := import(\"./sum.tengo\").",
    "Desc": " is equivalent to sum := import(\"./sum.tengo\")."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "sum := import(\"./sum.tengo\")",
    "Body": "sum := import(\"./sum.tengo\").",
    "Desc": "."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": ".tengo",
    "Body": ".tengo\" can\n    be customized. In that case, use the SetImportFileExt function of the\n    Compiler type.\n    See the  for details.",
    "Desc": "\" can\n    be customized. In that case, use the SetImportFileExt function of the\n    Compiler type.\n    See the  for details."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "SetImportFileExt",
    "Body": "SetImportFileExt function of the\n    Compiler type.\n    See the  for details.",
    "Desc": " function of the\n    Compiler type.\n    See the  for details."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "Compiler",
    "Body": "Compiler type.\n    See the  for details.",
    "Desc": " type.\n    See the  for details."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "import",
    "Body": "import expression loads the module code and execute it like a function.",
    "Desc": " expression loads the module code and execute it like a function."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "export",
    "Body": "export statement.",
    "Desc": " statement."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "export",
    "Body": "export a value of any types: int, map, function, etc.",
    "Desc": " a value of any types: int, map, function, etc."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "export",
    "Body": "export in a module is like return in a function: it stops execution and\nreturn a value to the importing code.",
    "Desc": " in a module is like return in a function: it stops execution and\nreturn a value to the importing code."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "return",
    "Body": "return in a function: it stops execution and\nreturn a value to the importing code.",
    "Desc": " in a function: it stops execution and\nreturn a value to the importing code."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "export",
    "Body": "export-ed values are always immutable.",
    "Desc": "-ed values are always immutable."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "export",
    "Body": "export statement, import expression\nsimply returns undefined. ",
    "Desc": " statement, import expression\nsimply returns undefined. "
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "import",
    "Body": "import expression\nsimply returns undefined. ",
    "Desc": " expression\nsimply returns undefined. "
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "undefined",
    "Body": "undefined. ",
    "Desc": ". "
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "return",
    "Body": "return.)",
    "Desc": ".)"
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "export",
    "Body": "export statement is completely ignored and not evaluated if\nthe code is executed as a main module.",
    "Desc": " statement is completely ignored and not evaluated if\nthe code is executed as a main module."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "import",
    "Body": "import expression to load the\n as\nwell.",
    "Desc": " expression to load the\n as\nwell."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "//...",
    "Body": "//...) and block comments\n(/* ... */).",
    "Desc": ") and block comments\n(/* ... */)."
  },
  {
    "Type": 0,
    "Module": "tutorial",
    "Object": "",
    "Code": "/* ... */",
    "Body": "/* ... */).",
    "Desc": ")."
  }
]
